{"version":3,"file":"prediction-models-DCU63o_D.js","sources":["../../src/lib/lvoModel.js","../../src/api/client.js","../../src/types/medical-types.js","../../src/logic/ich-volume-calculator.js"],"sourcesContent":["/**\n * Production LVO Model - Scientifically Calibrated (JavaScript Version)\n *\n * Implementation of GFAP + FAST-ED LVO prediction model with:\n * - Yeo-Johnson power transformation for GFAP\n * - Z-score normalization\n * - Logistic regression with calibrated thresholds\n * - Platt scaling for probability calibration\n */\n\n// Model parameters (scientifically calibrated via CalibratedClassifierCV)\nconst LAMBDA = -0.825559; // Yeo-Johnson lambda for GFAP transformation\nconst B0 = -0.408314; // Logistic regression intercept\nconst B_GFAP = -0.826450; // GFAP coefficient (negative = protective when transformed)\nconst B_FAST = 1.651521; // FAST-ED coefficient (positive = risk factor)\n\n// Standardization parameters (from training data statistics)\nconst MU_G = -0.000000; // Mean of transformed GFAP\nconst SIG_G = 1.000000; // Standard deviation of transformed GFAP\nconst MU_F = 3.701422; // Mean of FAST-ED\nconst SIG_F = 2.306173; // Standard deviation of FAST-ED\n\n// Platt scaling parameters (for probability calibration)\nconst A_PLATT = 1.117420; // Platt scaling slope\nconst B_PLATT = -1.032167; // Platt scaling intercept\n\n// Decision threshold\nconst FINAL_THRESHOLD = 0.333333; // Classification threshold\n\n// Validation constants\nconst NUMERIC_EPS = 1e-15;\nconst MAX_GFAP_WARNING = 50000;\nconst MIN_FAST_ED = 0;\nconst MAX_FAST_ED = 16;\n\n/**\n * Yeo-Johnson power transformation\n */\nfunction yeoJohnson(x, lambda) {\n  if (Math.abs(lambda) < NUMERIC_EPS) {\n    return Math.log(x + 1.0);\n  }\n  return ((x + 1.0) ** lambda - 1.0) / lambda;\n}\n\n/**\n * Z-score standardization\n */\nfunction standardize(value, mean, std) {\n  return (value - mean) / std;\n}\n\n/**\n * Logistic (sigmoid) function\n */\nfunction logistic(x) {\n  if (x > 500) {\n    return 1.0;\n  } // Prevent overflow\n  if (x < -500) {\n    return 0.0;\n  } // Prevent underflow\n  return 1.0 / (1.0 + Math.exp(-x));\n}\n\n/**\n * Input validation\n */\nfunction validateInputs(gfap, fasted) {\n  // Check for null/undefined\n  if (gfap == null) {\n    throw new Error('gfap is required');\n  }\n  if (fasted == null) {\n    throw new Error('fasted is required');\n  }\n\n  // Convert to numbers\n  const numGfap = Number(gfap);\n  const numFasted = Number(fasted);\n\n  // Check for valid numbers\n  if (!Number.isFinite(numGfap)) {\n    throw new Error('gfap must be a finite number');\n  }\n  if (!Number.isFinite(numFasted)) {\n    throw new Error('fasted must be a finite number');\n  }\n\n  // Check ranges\n  if (numGfap < 0) {\n    throw new Error('GFAP value must be non-negative');\n  }\n\n  return { gfap: numGfap, fasted: numFasted };\n}\n\n/**\n * Calculate LVO probability using scientifically calibrated model\n */\nexport function lvoProbability(gfap, fasted) {\n  const validated = validateInputs(gfap, fasted);\n\n  // Clamp FAST-ED to valid range\n  const clampedFasted = Math.max(MIN_FAST_ED, Math.min(MAX_FAST_ED, validated.fasted));\n\n  // Apply transformations\n  const gfapTransformed = yeoJohnson(validated.gfap, LAMBDA);\n  const gfapStandardized = standardize(gfapTransformed, MU_G, SIG_G);\n  const fastedStandardized = standardize(clampedFasted, MU_F, SIG_F);\n\n  // Calculate logit\n  const logit = B0 + B_GFAP * gfapStandardized + B_FAST * fastedStandardized;\n\n  // Apply Platt calibration\n  const calibratedLogit = A_PLATT * logit + B_PLATT;\n\n  // Return probability\n  return logistic(calibratedLogit);\n}\n\n/**\n * Binary classification using threshold\n */\nexport function lvoClass(gfap, fasted) {\n  const probability = lvoProbability(gfap, fasted);\n  return probability >= FINAL_THRESHOLD ? 1 : 0;\n}\n\n/**\n * Comprehensive prediction with detailed intermediate values\n */\nexport function predictLVO(gfap, fasted) {\n  const warnings = [];\n  let isValid = true;\n\n  try {\n    const validated = validateInputs(gfap, fasted);\n    const originalFasted = validated.fasted;\n\n    // Clamp FAST-ED and warn if out of range\n    const clampedFasted = Math.max(MIN_FAST_ED, Math.min(MAX_FAST_ED, validated.fasted));\n    if (clampedFasted !== originalFasted) {\n      warnings.push(`FAST-ED score clamped from ${originalFasted} to ${clampedFasted} (valid range: ${MIN_FAST_ED}-${MAX_FAST_ED})`);\n    }\n\n    // Warn for very high GFAP values\n    if (validated.gfap > MAX_GFAP_WARNING) {\n      warnings.push(`GFAP value ${validated.gfap} exceeds typical range (may indicate extreme case)`);\n    }\n\n    // Apply transformations\n    const gfapTransformed = yeoJohnson(validated.gfap, LAMBDA);\n    const gfapStandardized = standardize(gfapTransformed, MU_G, SIG_G);\n    const fastedStandardized = standardize(clampedFasted, MU_F, SIG_F);\n\n    // Calculate logit\n    const logit = B0 + B_GFAP * gfapStandardized + B_FAST * fastedStandardized;\n\n    // Apply Platt calibration\n    const calibratedLogit = A_PLATT * logit + B_PLATT;\n\n    // Calculate final probability\n    const probability = logistic(calibratedLogit);\n    const classification = probability >= FINAL_THRESHOLD ? 1 : 0;\n\n    return {\n      probability,\n      classification,\n      inputs: {\n        gfap: validated.gfap,\n        fasted: clampedFasted,\n      },\n      transformedValues: {\n        gfapTransformed,\n        gfapStandardized,\n        fastedStandardized,\n        logit,\n        calibratedLogit,\n      },\n      metadata: {\n        modelVersion: '2024.09.28-calibrated',\n        threshold: FINAL_THRESHOLD,\n        isValid,\n        warnings,\n      },\n    };\n  } catch (error) {\n    warnings.push(error.message);\n    isValid = false;\n\n    return {\n      probability: NaN,\n      classification: 0,\n      inputs: { gfap, fasted },\n      transformedValues: {\n        gfapTransformed: NaN,\n        gfapStandardized: NaN,\n        fastedStandardized: NaN,\n        logit: NaN,\n        calibratedLogit: NaN,\n      },\n      metadata: {\n        modelVersion: '2024.09.28-calibrated',\n        threshold: FINAL_THRESHOLD,\n        isValid,\n        warnings,\n      },\n    };\n  }\n}\n\n// Export constants for external use\nexport const MODEL_CONSTANTS = {\n  LAMBDA,\n  B0,\n  B_GFAP,\n  B_FAST,\n  MU_G,\n  SIG_G,\n  MU_F,\n  SIG_F,\n  A_PLATT,\n  B_PLATT,\n  FINAL_THRESHOLD,\n};\n","/**\n * Medical Prediction API Client - Refactored for Enterprise Architecture\n * Eliminates code duplication using BasePredictionClient patterns\n *\n * Key improvements:\n * - Single source of truth for API logic\n * - Consistent error handling across all endpoints\n * - DRY principle enforcement\n * - Enhanced medical validation\n * - Enterprise-grade logging and monitoring\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\nimport { API_URLS, APP_CONFIG, DEV_CONFIG } from '../config.js';\nimport { lvoProbability, lvoClass } from '../lib/lvoModel.js';\n\nimport { extractDriversFromResponse, extractProbabilityFromResponse, extractConfidenceFromResponse } from './drivers.js';\n\n// APIError class for medical API errors\nexport class APIError extends Error {\n  constructor(message, status, url) {\n    super(message);\n    this.name = 'APIError';\n    this.status = status;\n    this.url = url;\n  }\n}\n\n// MedicalAPIError class (same as APIError for compatibility)\nexport class MedicalAPIError extends APIError {\n  constructor(message, status, url) {\n    super(message, status, url);\n    this.name = 'MedicalAPIError';\n  }\n}\n\n// Helper function to format drivers from flat dictionary\nfunction formatDriversFromDict(drivers, predictionType) {\n  if (!drivers || typeof drivers !== 'object') {\n    return null;\n  }\n\n  const positive = [];\n  const negative = [];\n\n  Object.entries(drivers).forEach(([label, weight]) => {\n    if (typeof weight === 'number') {\n      if (weight > 0) {\n        positive.push({ label, weight });\n      } else if (weight < 0) {\n        negative.push({ label, weight: Math.abs(weight) });\n      }\n    }\n  });\n\n  // Sort by weight (descending)\n  positive.sort((a, b) => b.weight - a.weight);\n  negative.sort((a, b) => b.weight - a.weight);\n\n  return {\n    kind: 'flat_dictionary',\n    units: 'logit',\n    positive,\n    negative,\n    meta: {},\n  };\n}\n\n// Helper functions to replace basePredictionClient functionality\nconst clientHelpers = {\n  safeParseFloat: (value, defaultValue = 0) => {\n    const parsed = parseFloat(value);\n    return isNaN(parsed) ? defaultValue : parsed;\n  },\n\n  normalizeBooleans: (payload) => {\n    const normalized = { ...payload };\n    Object.keys(normalized).forEach((key) => {\n      if (normalized[key] === 'true' || normalized[key] === true) {\n        normalized[key] = 1;\n      } else if (normalized[key] === 'false' || normalized[key] === false) {\n        normalized[key] = 0;\n      }\n    });\n    return normalized;\n  },\n\n  async makeApiCall(endpoint, payload, endpointType = 'unknown') {\n    console.log(`[API] Making ${endpointType} request to:`, endpoint);\n    console.log('[API] Payload:', payload);\n\n    try {\n      const controller = new AbortController();\n      const timeout = endpoint.includes('full_stroke') ? 15000 : 8000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const normalizedPayload = this.normalizeBooleans(payload);\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Accept: 'application/json',\n        },\n        body: JSON.stringify(normalizedPayload),\n        signal: controller.signal,\n        mode: 'cors',\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Network error');\n        throw new MedicalAPIError(\n          `API request failed: ${response.status} ${response.statusText} - ${errorText}`,\n          response.status,\n          endpoint,\n        );\n      }\n\n      const result = await response.json();\n      console.log(`[API] ${endpointType} response:`, result);\n      console.log(`[API] ${endpointType} response keys:`, Object.keys(result));\n      console.log(`[API] ${endpointType} first key:`, Object.keys(result)[0]);\n      console.log(`[API] ${endpointType} first value:`, result[Object.keys(result)[0]]);\n      console.log(`[API] ${endpointType} probability:`, result.probability);\n      console.log(`[API] ${endpointType} ich_probability:`, result.ich_probability);\n\n      // Normalize response: some APIs return \"ich_probability\" instead of \"probability\"\n      if (!result.probability && result.ich_probability !== undefined) {\n        result.probability = result.ich_probability;\n        console.log(`[API] ${endpointType} normalized probability from ich_probability:`, result.probability);\n      }\n\n      return result;\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.warn(`[API] ${endpointType} request timeout`);\n        throw new MedicalAPIError(`Request timeout after ${timeout / 1000}s`, 408, endpoint);\n      }\n\n      if (error instanceof MedicalAPIError) {\n        throw error;\n      }\n\n      console.error(`[API] ${endpointType} request failed:`, error);\n      throw new MedicalAPIError(\n        `Network error: ${error.message}`,\n        0,\n        endpoint,\n      );\n    }\n  },\n\n  getRequestStats: () => ({ requests: 0, errors: 0, avgResponseTime: 0 }),\n  cancelAllRequests: () => console.log('Cancel requests - not implemented'),\n\n  async predict(moduleType, payload) {\n    const endpointMap = {\n      coma_ich: API_URLS.COMA_ICH,\n      limited_ich: API_URLS.LDM_ICH,\n      full_stroke: API_URLS.FULL_STROKE,\n      lvo: API_URLS.LVO_PREDICTION,\n    };\n\n    const endpoint = endpointMap[moduleType];\n    if (!endpoint) {\n      throw new MedicalAPIError(`Unknown module type: ${moduleType}`, 400, 'unknown');\n    }\n\n    return await this.makeApiCall(endpoint, payload, moduleType);\n  },\n};\n\n/**\n * Warm up Google Cloud Functions on app load\n * Optimized for production reliability\n */\nexport async function warmUpFunctions() {\n  console.log('Warming up Cloud Functions...');\n\n  const prioritizedUrls = [\n    API_URLS.FULL_STROKE, // Warm this first - most complex\n    API_URLS.LVO_PREDICTION, // New LVO endpoint\n    API_URLS.COMA_ICH,\n    API_URLS.LDM_ICH,\n    API_URLS.AUTHENTICATE,\n  ];\n\n  const warmUpPromises = prioritizedUrls.map(async (url, index) => {\n    await new Promise((resolve) => setTimeout(resolve, index * 200));\n\n    try {\n      const controller = new AbortController();\n      const timeout = url.includes('full_stroke') ? 8000 : 3000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n        signal: controller.signal,\n        mode: 'cors',\n      });\n\n      clearTimeout(timeoutId);\n      console.log(`✓ Warmed up: ${url.split('/').pop()}`);\n    } catch (error) {\n      console.log(`✓ Warm-up attempt for ${url.split('/').pop()} completed`);\n    }\n  });\n\n  Promise.all(warmUpPromises).then(() => {\n    console.log('✅ Cloud Functions warm-up complete');\n  }).catch(() => {\n    // Silently handle errors\n  });\n}\n\n/**\n * COMA ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for coma module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictComaIch(payload) {\n  try {\n    return await clientHelpers.predict('coma_ich', payload);\n  } catch (error) {\n    // Transform MedicalAPIError back to APIError for backward compatibility\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = 'APIError';\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * Limited Data ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for limited data module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictLimitedIch(payload) {\n  try {\n    return await clientHelpers.predict('limited_ich', payload);\n  } catch (error) {\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = 'APIError';\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * LVO Prediction with Enhanced Fallback Logic\n * @param {Object} payload - Patient data for LVO assessment\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} LVO prediction result\n */\nexport async function predictLVO(payload, retryCount = 0) {\n  console.log('[API] predictLVO called with payload:', payload);\n\n  if (!payload.gfap_value || !payload.fast_ed_score) {\n    throw new MedicalAPIError(\n      'Missing required parameters: gfap_value and fast_ed_score',\n      400,\n      API_URLS.LVO_PREDICTION,\n    );\n  }\n\n  console.log('[API] LVO payload preparation...');\n\n  try {\n    // Try enterprise client first\n    console.log('🌩️ Using LVO Cloud Function (primary)');\n    const result = await clientHelpers.predict('lvo', payload);\n    console.log('[API] LVO Cloud Function response:', result);\n    return result;\n  } catch (error) {\n    console.warn('⚠️ LVO Cloud Function failed, falling back to local model:', error.message);\n    console.log('🏠 Using New LVO Model (fallback)');\n\n    try {\n      const gfapValue = parseFloat(payload.gfap_value);\n      const fastEdScore = parseInt(payload.fast_ed_score);\n\n      if (isNaN(gfapValue) || isNaN(fastEdScore)) {\n        throw new Error('Invalid GFAP or FAST-ED values');\n      }\n\n      const probability = lvoProbability(gfapValue, fastEdScore);\n      const classification = lvoClass(gfapValue, fastEdScore);\n\n      const drivers = {\n        kind: 'new_model_fallback',\n        units: 'normalized_contribution',\n        positive: [\n          { label: 'GFAP Biomarker', weight: gfapValue > 100 ? 0.6 : 0.3 },\n          { label: 'FAST-ED Score', weight: fastEdScore * 0.1 },\n        ].sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)),\n        negative: [],\n        meta: {\n          riskLevel: probability > 0.7 ? 'high' : probability > 0.4 ? 'moderate' : 'low',\n          interpretation: `${(probability * 100).toFixed(1)}% LVO probability (${classification === 1 ? 'Positive' : 'Negative'})`,\n        },\n      };\n\n      return {\n        probability,\n        drivers,\n        confidence: probability > 0.7 ? 0.9 : probability > 0.4 ? 0.7 : 0.5,\n        module: 'New LVO Model (Scientifically Calibrated)',\n        interpretation: `${(probability * 100).toFixed(1)}% LVO probability based on GFAP=${gfapValue} and FAST-ED=${fastEdScore}`,\n      };\n    } catch (localError) {\n      console.warn('⚠️ New LVO Model fallback failed:', localError.message);\n      throw new MedicalAPIError(\n        `LVO prediction failed: ${error.message}`,\n        error.status || 500,\n        API_URLS.LVO_PREDICTION,\n      );\n    }\n  }\n}\n\n/**\n * Full Stroke Prediction - Enhanced with Enterprise Patterns\n * @param {Object} payload - Complete patient data\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} Complete stroke assessment\n */\nexport async function predictFullStroke(payload, retryCount = 0) {\n  console.log('[API] predictFullStroke called with payload:', payload);\n  console.log('[API] isLocalPreview():', isLocalPreview());\n\n  try {\n    // Get ICH prediction using enterprise client\n    const fullStrokeResponse = await clientHelpers.predict('full_stroke', payload);\n    console.log('[API] Full stroke raw response:', fullStrokeResponse);\n\n    // Extract ICH data from nested structure\n    const ichResult = fullStrokeResponse.ich_prediction || {};\n    console.log('[API] Extracted ICH data:', ichResult);\n\n    // Get LVO prediction using enhanced LVO function\n    let lvoResult = null;\n    try {\n      console.log('🔄 Using dedicated LVO prediction (cloud function + fallback)');\n      lvoResult = await predictLVO(payload);\n      console.log('✅ LVO prediction successful via dedicated function');\n    } catch (lvoError) {\n      console.warn('⚠️ Dedicated LVO prediction failed:', lvoError);\n\n      // Fallback: try to extract LVO from full stroke response if available\n      if (ichResult.lvo_prediction) {\n        lvoResult = {\n          probability: ichResult.lvo_prediction.probability || 0,\n          drivers: ichResult.lvo_prediction.drivers || null,\n          confidence: ichResult.lvo_prediction.confidence || 0.8,\n          module: 'Full Stroke (API Fallback)',\n        };\n      } else {\n        // Final fallback to local LVO model\n        lvoResult = await predictLVO(payload);\n      }\n    }\n\n    return {\n      ich: {\n        probability: ichResult.probability,\n        drivers: ichResult.drivers ? formatDriversFromDict(ichResult.drivers, 'ICH') : ichResult.drivers,\n        confidence: ichResult.confidence,\n        module: ichResult.module,\n      },\n      lvo: lvoResult,\n    };\n  } catch (error) {\n    console.error('Full Stroke prediction failed:', error);\n\n    if (error.status === 408 && retryCount < 1) {\n      console.log('⏱️ Retrying Full Stroke API (cold start detected)...');\n      return predictFullStroke(payload, retryCount + 1);\n    }\n\n    // Use local preview fallback for development\n    if (isLocalPreview()) {\n      const mockData = DEV_CONFIG.mockApiResponses.full_stroke;\n      const ichPrediction = mockData.ich_prediction || {};\n      const lvoPrediction = mockData.lvo_prediction || {};\n\n      return {\n        ich: {\n          probability: clientHelpers.safeParseFloat(ichPrediction.probability, 0),\n          drivers: ichPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(ichPrediction.confidence, 0.85),\n          module: 'Full Stroke (Mock)',\n        },\n        lvo: {\n          probability: clientHelpers.safeParseFloat(lvoPrediction.probability, 0),\n          drivers: lvoPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(lvoPrediction.confidence, 0.85),\n          module: 'Full Stroke (Mock)',\n        },\n      };\n    }\n\n    throw new MedicalAPIError(\n      `Failed to get stroke predictions: ${error.message}`,\n      error.status,\n      API_URLS.FULL_STROKE,\n    );\n  }\n}\n\n/**\n * Helper function to check if running in local preview\n * @returns {boolean} True if local preview environment\n */\nfunction isLocalPreview() {\n  return ['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname);\n}\n\n/**\n * Re-export utility functions for backward compatibility\n */\nexport const normalizeBooleans = (payload) => clientHelpers.normalizeBooleans(payload);\nexport const safeParseFloat = (value, defaultValue) => clientHelpers.safeParseFloat(value, defaultValue);\n\n/**\n * Get API client statistics for monitoring\n * @returns {Object} Client statistics\n */\nexport function getClientStats() {\n  return clientHelpers.getRequestStats();\n}\n\n/**\n * Cancel all active API requests\n */\nexport function cancelAllRequests() {\n  clientHelpers.cancelAllRequests();\n}\n","/**\n * Medical Type Definitions for iGFAP Stroke Triage Assistant\n * Provides comprehensive type safety for medical calculations and data\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\n/**\n * @typedef {Object} PatientData\n * @property {number} age - Patient age in years (0-120)\n * @property {string} gender - Patient gender ('male' | 'female' | 'other')\n * @property {number} gfap - GFAP biomarker level in pg/mL (29-10001)\n * @property {number} [nihss] - NIHSS score (0-42)\n * @property {number} [gcs] - Glasgow Coma Scale (3-15)\n * @property {boolean} [hypertension] - History of hypertension\n * @property {boolean} [diabetes] - History of diabetes\n * @property {boolean} [smoking] - Smoking status\n * @property {number} [sbp] - Systolic blood pressure (mmHg)\n * @property {number} [dbp] - Diastolic blood pressure (mmHg)\n */\n\n/**\n * @typedef {Object} ICHRiskResult\n * @property {number} probability - ICH risk probability (0-1)\n * @property {number} percentage - ICH risk percentage (0-100)\n * @property {'low'|'moderate'|'high'|'critical'} riskLevel - Risk classification\n * @property {string} module - Module used for calculation\n * @property {string} timestamp - ISO timestamp of calculation\n */\n\n/**\n * @typedef {Object} ICHVolumeResult\n * @property {number} volume - Predicted volume in mL\n * @property {number} confidence - Confidence level (0-1)\n * @property {'small'|'moderate'|'large'|'massive'} volumeCategory - Volume classification\n * @property {string} timestamp - ISO timestamp of calculation\n */\n\n/**\n * @typedef {Object} ValidationResult\n * @property {boolean} isValid - Whether the data is valid\n * @property {string[]} errors - Array of validation error messages\n * @property {string[]} warnings - Array of validation warnings\n */\n\n/**\n * @typedef {Object} PredictionRequest\n * @property {PatientData} data - Patient data for prediction\n * @property {string} module - Module type ('coma'|'limited'|'full')\n * @property {string} timestamp - ISO timestamp of request\n * @property {string} sessionId - Session identifier\n */\n\n/**\n * @typedef {Object} PredictionResponse\n * @property {boolean} success - Whether prediction was successful\n * @property {ICHRiskResult} [ichRisk] - ICH risk prediction result\n * @property {ICHVolumeResult} [ichVolume] - ICH volume prediction result\n * @property {string} [error] - Error message if prediction failed\n * @property {number} processingTime - Time taken for prediction (ms)\n */\n\n/**\n * @typedef {Object} QualityMetric\n * @property {string} name - Metric name\n * @property {'count'|'duration'|'percentage'|'average'} type - Metric type\n * @property {number} value - Metric value\n * @property {string} timestamp - ISO timestamp\n * @property {Object} [metadata] - Additional metric metadata\n */\n\n/**\n * @typedef {Object} AuditEvent\n * @property {string} eventType - Type of event ('data_entry'|'prediction'|'error')\n * @property {string} timestamp - ISO timestamp\n * @property {string} userId - User identifier\n * @property {Object} data - Event-specific data\n * @property {string} [sessionId] - Session identifier\n */\n\n/**\n * @typedef {Object} SessionInfo\n * @property {string} sessionId - Unique session identifier\n * @property {string} userId - User identifier\n * @property {number} startTime - Session start timestamp\n * @property {number} lastActivity - Last activity timestamp\n * @property {boolean} isValid - Whether session is still valid\n */\n\n/**\n * @typedef {Object} AppStatus\n * @property {boolean} isInitialized - Whether app is initialized\n * @property {boolean} isAuthenticated - Whether user is authenticated\n * @property {string} currentScreen - Current screen name\n * @property {Object} features - Feature availability status\n * @property {string} version - Application version\n */\n\n/**\n * @typedef {Object} ErrorContext\n * @property {string} operation - Operation being performed\n * @property {string} [component] - Component where error occurred\n * @property {Object} [metadata] - Additional error metadata\n * @property {string} timestamp - ISO timestamp\n */\n\n/**\n * @typedef {Object} SafeOperationOptions\n * @property {'AUTHENTICATION'|'NETWORK'|'MEDICAL'|'STORAGE'|'RENDERING'} category - Error category\n * @property {'LOW'|'MEDIUM'|'HIGH'|'CRITICAL'} severity - Error severity\n * @property {number} [timeout] - Operation timeout in milliseconds\n * @property {number} [retries] - Number of retry attempts\n * @property {ErrorContext} context - Error context information\n */\n\n/**\n * Type validation functions\n */\n\n/**\n * Validates patient data structure and ranges\n * @param {any} data - Data to validate\n * @returns {ValidationResult} Validation result\n */\nexport function validatePatientData(data) {\n  const errors = [];\n  const warnings = [];\n\n  if (!data || typeof data !== 'object') {\n    errors.push('Patient data must be an object');\n    return { isValid: false, errors, warnings };\n  }\n\n  // Required fields validation\n  if (typeof data.age !== 'number' || data.age < 0 || data.age > 120) {\n    errors.push('Age must be a number between 0 and 120');\n  }\n\n  if (!['male', 'female', 'other'].includes(data.gender)) {\n    errors.push('Gender must be \"male\", \"female\", or \"other\"');\n  }\n\n  if (typeof data.gfap !== 'number' || data.gfap < 29 || data.gfap > 10001) {\n    errors.push('GFAP must be a number between 29 and 10001 pg/mL');\n  }\n\n  // Optional fields validation\n  if (data.nihss !== undefined && (typeof data.nihss !== 'number' || data.nihss < 0 || data.nihss > 42)) {\n    errors.push('NIHSS must be a number between 0 and 42');\n  }\n\n  if (data.gcs !== undefined && (typeof data.gcs !== 'number' || data.gcs < 3 || data.gcs > 15)) {\n    errors.push('GCS must be a number between 3 and 15');\n  }\n\n  if (data.sbp !== undefined && (typeof data.sbp !== 'number' || data.sbp < 50 || data.sbp > 300)) {\n    warnings.push('Systolic BP should typically be between 50-300 mmHg');\n  }\n\n  if (data.dbp !== undefined && (typeof data.dbp !== 'number' || data.dbp < 30 || data.dbp > 200)) {\n    warnings.push('Diastolic BP should typically be between 30-200 mmHg');\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n}\n\n/**\n * Validates ICH risk result\n * @param {any} result - Result to validate\n * @returns {ValidationResult} Validation result\n */\nexport function validateICHRiskResult(result) {\n  const errors = [];\n  const warnings = [];\n\n  if (!result || typeof result !== 'object') {\n    errors.push('ICH risk result must be an object');\n    return { isValid: false, errors, warnings };\n  }\n\n  if (typeof result.probability !== 'number' || result.probability < 0 || result.probability > 1) {\n    errors.push('Probability must be a number between 0 and 1');\n  }\n\n  if (typeof result.percentage !== 'number' || result.percentage < 0 || result.percentage > 100) {\n    errors.push('Percentage must be a number between 0 and 100');\n  }\n\n  if (!['low', 'moderate', 'high', 'critical'].includes(result.riskLevel)) {\n    errors.push('Risk level must be \"low\", \"moderate\", \"high\", or \"critical\"');\n  }\n\n  if (!result.timestamp || !Date.parse(result.timestamp)) {\n    errors.push('Timestamp must be a valid ISO date string');\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n}\n\n/**\n * Type guard functions\n */\n\n/**\n * Checks if value is valid patient data\n * @param {any} value - Value to check\n * @returns {value is PatientData} Type guard result\n */\nexport function isPatientData(value) {\n  const validation = validatePatientData(value);\n  return validation.isValid;\n}\n\n/**\n * Checks if value is valid ICH risk result\n * @param {any} value - Value to check\n * @returns {value is ICHRiskResult} Type guard result\n */\nexport function isICHRiskResult(value) {\n  const validation = validateICHRiskResult(value);\n  return validation.isValid;\n}\n\n/**\n * Medical calculation constants with type safety\n */\nexport const MEDICAL_CONSTANTS = {\n  /** @type {[number, number]} Age range */\n  AGE_RANGE: [0, 120],\n\n  /** @type {[number, number]} GFAP range in pg/mL */\n  GFAP_RANGE: [29, 10001],\n\n  /** @type {[number, number]} NIHSS range */\n  NIHSS_RANGE: [0, 42],\n\n  /** @type {[number, number]} GCS range */\n  GCS_RANGE: [3, 15],\n\n  /** @type {Object.<string, number>} Risk thresholds */\n  RISK_THRESHOLDS: {\n    LOW: 0.25,\n    MODERATE: 0.50,\n    HIGH: 0.70,\n    CRITICAL: 0.85,\n  },\n\n  /** @type {Object.<string, number>} Volume thresholds in mL */\n  VOLUME_THRESHOLDS: {\n    SMALL: 10,\n    MODERATE: 30,\n    LARGE: 60,\n    MASSIVE: 100,\n  },\n};\n\n/**\n * Runtime type checking utility\n */\nexport class TypeChecker {\n  /**\n   * Ensures value matches expected type with detailed error\n   * @param {any} value - Value to check\n   * @param {string} expectedType - Expected type description\n   * @param {string} fieldName - Field name for error messages\n   * @throws {TypeError} If type check fails\n   */\n  static ensureType(value, expectedType, fieldName) {\n    let isValid = false;\n    let actualType = typeof value;\n\n    switch (expectedType) {\n      case 'PatientData':\n        isValid = isPatientData(value);\n        actualType = 'Invalid PatientData';\n        break;\n      case 'ICHRiskResult':\n        isValid = isICHRiskResult(value);\n        actualType = 'Invalid ICHRiskResult';\n        break;\n      case 'number':\n        isValid = typeof value === 'number' && !isNaN(value);\n        break;\n      case 'string':\n        isValid = typeof value === 'string';\n        break;\n      case 'boolean':\n        isValid = typeof value === 'boolean';\n        break;\n      default:\n        isValid = typeof value === expectedType;\n    }\n\n    if (!isValid) {\n      throw new TypeError(\n        `Type error in ${fieldName}: expected ${expectedType}, got ${actualType}. `\n        + 'This is a critical error in medical calculations.',\n      );\n    }\n  }\n\n  /**\n   * Validates number is within range\n   * @param {number} value - Value to check\n   * @param {[number, number]} range - [min, max] range\n   * @param {string} fieldName - Field name for error messages\n   * @throws {RangeError} If value is out of range\n   */\n  static ensureRange(value, range, fieldName) {\n    this.ensureType(value, 'number', fieldName);\n    const [min, max] = range;\n\n    if (value < min || value > max) {\n      throw new RangeError(\n        `Range error in ${fieldName}: value ${value} must be between ${min} and ${max}. `\n        + 'This is a critical error in medical calculations.',\n      );\n    }\n  }\n}\n","/**\n * ICH Volume Calculation and Clinical Assessment\n * Based on validated log-log regression model (R² = 0.476)\n * Formula: log₁₀(Volume) = 0.0192 + 0.4533 × log₁₀(GFAP)\n *\n * @typedef {import('../types/medical-types.js').ICHVolumeResult} ICHVolumeResult\n * @typedef {import('../types/medical-types.js').ValidationResult} ValidationResult\n */\n\n// Bulletproof error handling utilities\nimport {\n  safeAsync,\n  safeMedicalCalculation,\n  MedicalError,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  MEDICAL_ERROR_CODES,\n  validateMedicalInputs,\n} from '../utils/error-handler.js';\n\n// Type safety utilities\nimport { TypeChecker, MEDICAL_CONSTANTS } from '../types/medical-types.js';\n\n// Professional logging\nimport { medicalLogger, LOG_CATEGORIES } from '../utils/medical-logger.js';\n\n// Volume-based risk thresholds with clinical significance\nexport const VOLUME_THRESHOLDS = {\n  low: {\n    max: 10, color: '#dc2626', label: 'Small', severity: 'low',\n  },\n  moderate: {\n    min: 10, max: 20, color: '#dc2626', label: 'Moderate', severity: 'moderate',\n  },\n  high: {\n    min: 20, max: 30, color: '#dc2626', label: 'Large', severity: 'high',\n  },\n  critical: {\n    min: 30, color: '#dc2626', label: 'Critical', severity: 'critical',\n  },\n};\n\n// 30-day mortality rates by hemorrhage volume (based on clinical literature)\n// Calibrated to Broderick et al. (1993) landmark study:\n// - 30ml = 19% mortality\n// - 60ml = 91% mortality\n// With correlation strengths from observational data\n// Reference thresholds for documentation purposes:\nexport const MORTALITY_BY_VOLUME = {\n  '<10ml': '5-10%', // Minor hemorrhage\n  '10-30ml': '10-19%', // Small (Broderick: 30ml=19%)\n  '30-50ml': '19-44%', // Moderate (interpolated)\n  '50-60ml': '44-91%', // Large (Broderick: 60ml=91%)\n  '≥60ml': '91-100%', // Massive (Broderick: >60ml=91-100%)\n};\n\n/**\n * Calculate ICH volume from GFAP biomarker value with bulletproof error handling\n * @param {number} gfapValue - GFAP value in pg/ml (29-10,001)\n * @returns {Promise<ICHVolumeResult>} Volume calculation results with type safety\n */\nexport async function calculateICHVolume(gfapValue) {\n  return safeMedicalCalculation(\n    async (inputs) => {\n      const { gfap } = inputs;\n\n      medicalLogger.info('ICH volume calculation started', {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        operation: 'ich_volume_calculation',\n      });\n\n      // Type safety validation first\n      TypeChecker.ensureType(gfap, 'number', 'GFAP value');\n      TypeChecker.ensureRange(gfap, MEDICAL_CONSTANTS.GFAP_RANGE, 'GFAP value');\n\n      // Validate medical input\n      const validation = validateMedicalInputs(\n        { gfap },\n        {\n          gfap: {\n            required: true,\n            type: 'number',\n            min: 0,\n            max: 10001,\n            warningMin: 29,\n            warningMax: 10000,\n          },\n        },\n      );\n\n      if (!validation.isValid) {\n        throw new MedicalError(\n          validation.errors[0]?.message || 'Invalid GFAP value',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ validationErrors: validation.errors, gfapValue: gfap });\n      }\n\n      // Handle edge cases\n      if (!gfap || gfap <= 0) {\n        return {\n          volume: 0,\n          volumeRange: { min: 0, max: 0 },\n          riskLevel: 'low',\n          mortalityRate: '~0%',\n          isValid: true,\n          calculation: 'No hemorrhage detected',\n          warnings: [],\n        };\n      }\n\n      // Cap extremely high GFAP values\n      const cappedGfap = Math.min(gfap, 10000);\n      const warnings = [];\n      if (gfap > 10000) {\n        warnings.push(`GFAP value ${gfap} exceeds maximum calculation range and was capped at 10,000 pg/ml`);\n      }\n\n      // Values above 10,000 pg/ml are capped for calculation stability\n      if (cappedGfap !== gfap) {\n        warnings.push('GFAP value was adjusted for calculation stability');\n      }\n\n      // Apply log-log regression formula with error checking\n      if (cappedGfap <= 0) {\n        throw new MedicalError(\n          'GFAP value must be positive for volume calculation',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ gfapValue: cappedGfap });\n      }\n\n      const logGfap = Math.log10(cappedGfap);\n      if (!isFinite(logGfap)) {\n        throw new MedicalError(\n          'Invalid logarithm calculation for GFAP value',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ gfapValue: cappedGfap, logValue: logGfap });\n      }\n\n      const logVolume = 0.0192 + 0.4533 * logGfap;\n      if (!isFinite(logVolume)) {\n        throw new MedicalError(\n          'Invalid volume calculation result',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ logGfap, logVolume });\n      }\n\n      const calculatedVolume = 10 ** logVolume;\n      if (!isFinite(calculatedVolume) || calculatedVolume < 0) {\n        throw new MedicalError(\n          'Calculated volume is invalid',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ logVolume, calculatedVolume });\n      }\n\n      // Calculate confidence range (±30%)\n      const volumeRange = {\n        min: calculatedVolume * 0.7,\n        max: calculatedVolume * 1.3,\n      };\n\n      // Determine risk level based on volume\n      const riskLevel = getVolumeRiskLevel(calculatedVolume);\n\n      // Get mortality rate\n      const mortalityRate = getMortalityRate(calculatedVolume);\n\n      // Format volume for display\n      const displayVolume = calculatedVolume < 1 ? '<1' : calculatedVolume.toFixed(1);\n\n      // Safety check for extreme values\n      if (calculatedVolume > 200) {\n        warnings.push('Calculated volume is extremely high - please verify GFAP measurement');\n      }\n\n      /** @type {ICHVolumeResult} */\n      const result = {\n        volume: calculatedVolume,\n        confidence: 0.476, // R² of the regression model\n        volumeCategory: getVolumeCategory(calculatedVolume),\n        timestamp: new Date().toISOString(),\n        // Legacy properties for backward compatibility\n        displayVolume,\n        volumeRange: {\n          min: volumeRange.min.toFixed(1),\n          max: volumeRange.max.toFixed(1),\n        },\n        riskLevel,\n        mortalityRate,\n        isValid: true,\n        calculation: `Based on GFAP ${gfap} pg/ml`,\n        threshold: calculatedVolume >= 30 ? 'SURGICAL' : calculatedVolume >= 20 ? 'HIGH_RISK' : 'MANAGEABLE',\n        warnings,\n        metadata: {\n          originalGfap: gfap,\n          cappedGfap,\n          calculationTimestamp: new Date().toISOString(),\n        },\n      };\n\n      // Validate final result\n      if (typeof result.volume !== 'number' || !isFinite(result.volume)) {\n        medicalLogger.error('ICH volume calculation result validation failed', {\n          category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n          gfapValue: gfap,\n          resultVolume: result.volume,\n          resultType: typeof result.volume,\n        });\n        throw new MedicalError(\n          'Final volume calculation result is invalid',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.CRITICAL,\n        ).withContext({ result });\n      }\n\n      medicalLogger.info('ICH volume calculation completed successfully', {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        calculatedVolume: result.volume,\n        volumeCategory: result.volumeCategory,\n        riskLevel: result.riskLevel,\n        confidence: result.confidence,\n      });\n\n      return result;\n    },\n    { gfap: gfapValue },\n    {\n      timeout: 5000,\n      fallback: (error) => ({\n        volume: 0,\n        volumeRange: { min: 0, max: 0 },\n        riskLevel: 'low',\n        mortalityRate: 'Calculation unavailable',\n        isValid: false,\n        calculation: 'Calculation error - using fallback',\n        error: error.message,\n        fallbackUsed: true,\n        warnings: ['Volume calculation failed - fallback values used'],\n      }),\n      context: {\n        operation: 'ich_volume_calculation',\n        gfapValue,\n        formula: 'log₁₀(Volume) = 0.0192 + 0.4533 × log₁₀(GFAP)',\n      },\n    },\n  );\n}\n\n/**\n * Fast synchronous volume estimate for UI rendering\n * Mirrors the main formula without async/error wrappers.\n * @param {number} gfap\n * @returns {number} estimated volume in ml (>= 0)\n */\nexport function estimateVolumeFromGFAP(gfap) {\n  try {\n    const v = Math.max(0, 10 ** (0.0192 + 0.4533 * Math.log10(Math.max(1, Math.min(gfap, 10000)))));\n    return Number.isFinite(v) ? v : 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Estimate mortality band from volume (synchronous, display-only)\n * @param {number} volume\n * @returns {string}\n */\nexport function estimateMortalityFromVolume(volume) {\n  if (!Number.isFinite(volume) || volume <= 0) {\n    return '5-10%';\n  }\n  if (volume >= 60) {\n    return '91-100%';\n  }\n  if (volume >= 50) {\n    return '44-91%';\n  }\n  if (volume >= 30) {\n    return '19-44%';\n  }\n  if (volume >= 10) {\n    return '10-19%';\n  }\n  return '5-10%';\n}\n\n/**\n * Determine risk level based on calculated volume with safety checks\n * @param {number} volume - Calculated volume in ml\n * @returns {string} Risk level key\n */\nfunction getVolumeRiskLevel(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== 'number' || !isFinite(volume)) {\n      throw new MedicalError(\n        'Invalid volume for risk level calculation',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      throw new MedicalError(\n        'Volume cannot be negative',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume });\n    }\n\n    if (volume >= VOLUME_THRESHOLDS.critical.min) {\n      return 'critical';\n    }\n    if (volume >= VOLUME_THRESHOLDS.high.min) {\n      return 'high';\n    }\n    if (volume >= VOLUME_THRESHOLDS.moderate.min) {\n      return 'moderate';\n    }\n    return 'low';\n  } catch (error) {\n    // Fallback to 'low' for safety\n    console.warn('Risk level calculation failed, defaulting to low:', error.message);\n    return 'low';\n  }\n}\n\n/**\n * Get mortality rate based on volume with improved interpolation and safety checks\n * Calibrated to match clinical studies (Broderick 1993: 30ml=19%, 60ml=91%)\n * @param {number} volume - Volume in ml\n * @returns {string} Mortality rate string with citation\n */\nfunction getMortalityRate(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== 'number' || !isFinite(volume)) {\n      throw new MedicalError(\n        'Invalid volume for mortality rate calculation',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      return 'Invalid volume';\n    }\n\n    // For very small hemorrhages\n    if (volume < 10) {\n      return '5-10%⁴';\n    }\n\n    // For small hemorrhages (10-30ml)\n    // Broderick: 30ml = 19% mortality\n    if (volume < 30) {\n      // Linear interpolation: 10ml=10%, 30ml=19%\n      const rate = Math.round(10 + (volume - 10) * (19 - 10) / (30 - 10));\n      // Validate interpolated rate\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%⁴`;\n    }\n\n    // For moderate hemorrhages (30-50ml)\n    // Interpolating from Broderick 30ml=19% to 50ml≈44%\n    if (volume < 50) {\n      // Linear interpolation: 30ml=19%, 50ml=44%\n      const rate = Math.round(19 + (volume - 30) * (44 - 19) / (50 - 30));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%³`;\n    }\n\n    // For large hemorrhages (50-60ml)\n    // Broderick: 60ml = 91% mortality\n    if (volume < 60) {\n      // Steeper increase: 50ml=44%, 60ml=91%\n      const rate = Math.round(44 + (volume - 50) * (91 - 44) / (60 - 50));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%²`;\n    }\n\n    // For massive hemorrhages (≥60ml)\n    // Broderick: >60ml = 91-100%\n    if (volume < 80) {\n      // 60ml=91%, 80ml=96%\n      const rate = Math.round(91 + (volume - 60) * (96 - 91) / (80 - 60));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¹`;\n    }\n\n    // For extreme cases (≥80ml)\n    return '96-100%¹';\n  } catch (error) {\n    // Fallback for safety\n    console.warn('Mortality rate calculation failed:', error.message);\n    return 'Rate unavailable';\n  }\n}\n\n/**\n * Calculate hemorrhage size percentage for visualization with safety checks\n * Based on brain area scaling: 30ml = ~40% of brain area, 100ml = ~70%\n * @param {number} volume - Volume in ml\n * @returns {Promise<number>} Percentage of brain area (0-70)\n */\nexport async function calculateHemorrhageSizePercent(volume) {\n  return safeAsync(\n    async () => {\n      // Input validation\n      if (typeof volume !== 'number' || !isFinite(volume)) {\n        throw new MedicalError(\n          'Invalid volume for size percentage calculation',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, type: typeof volume });\n      }\n\n      if (volume < 0) {\n        throw new MedicalError(\n          'Volume cannot be negative for visualization',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume });\n      }\n\n      if (volume <= 0) {\n        return 0;\n      }\n      if (volume >= 100) {\n        return 70;\n      } // Maximum 70% of brain area\n\n      // Non-linear scaling for realistic appearance\n      // 30ml = 40%, 100ml = 70%\n      const sqrtValue = Math.sqrt(volume / 30);\n      if (!isFinite(sqrtValue)) {\n        throw new MedicalError(\n          'Invalid square root calculation for visualization',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, sqrtValue });\n      }\n\n      const basePercent = sqrtValue * 40;\n      const result = Math.min(basePercent, 70);\n\n      // Final validation\n      if (!isFinite(result) || result < 0 || result > 100) {\n        throw new MedicalError(\n          'Calculated percentage out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, basePercent, result });\n      }\n\n      return result;\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 1000,\n      fallback: () => {\n        // Safe fallback based on simple linear scaling\n        if (volume <= 0) {\n          return 0;\n        }\n        if (volume >= 100) {\n          return 70;\n        }\n        return Math.min((volume / 100) * 70, 70);\n      },\n      context: {\n        operation: 'hemorrhage_size_calculation',\n        volume,\n      },\n    },\n  );\n}\n\n/**\n * Get color for volume visualization\n * @param {number} volume - Volume in ml\n * @returns {string} CSS color value\n */\nexport function getVolumeColor(volume) {\n  const riskLevel = getVolumeRiskLevel(volume);\n  return VOLUME_THRESHOLDS[riskLevel].color;\n}\n\n/**\n * Test function for validation with comprehensive error handling\n * Tests the calculator with known GFAP values\n */\nexport async function testVolumeCalculator() {\n  return safeAsync(\n    async () => {\n      const testCases = [\n        { gfap: 100, expectedVolume: '~5ml' },\n        { gfap: 500, expectedVolume: '~15ml' },\n        { gfap: 1000, expectedVolume: '~21ml' },\n        { gfap: 1500, expectedVolume: '~28ml' },\n        { gfap: 3000, expectedVolume: '~50ml' },\n        { gfap: 5000, expectedVolume: '~72ml' },\n      ];\n\n      // ICH Volume Calculator Test Results\n      const results = await Promise.allSettled(\n        testCases.map(async (test) => {\n          try {\n            const result = await calculateICHVolume(test.gfap);\n            return {\n              gfap: test.gfap, result, expected: test.expectedVolume, success: true,\n            };\n          } catch (error) {\n            return {\n              gfap: test.gfap,\n              result: null,\n              expected: test.expectedVolume,\n              success: false,\n              error: error.message,\n            };\n          }\n        }),\n      );\n\n      // Process results and handle any failures\n      const processedResults = results.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        }\n        return {\n          gfap: testCases[index].gfap,\n          result: null,\n          expected: testCases[index].expectedVolume,\n          success: false,\n          error: result.reason?.message || 'Test failed',\n        };\n      });\n\n      const successfulTests = processedResults.filter((r) => r.success).length;\n      const totalTests = testCases.length;\n\n      return {\n        results: processedResults,\n        summary: {\n          total: totalTests,\n          successful: successfulTests,\n          failed: totalTests - successfulTests,\n          successRate: `${Math.round((successfulTests / totalTests) * 100)}%`,\n        },\n        timestamp: new Date().toISOString(),\n      };\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 10000,\n      fallback: (error) => ({\n        results: [],\n        summary: {\n          total: 0,\n          successful: 0,\n          failed: 0,\n          successRate: '0%',\n        },\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }),\n      context: {\n        operation: 'volume_calculator_test',\n      },\n    },\n  );\n}\n\n/**\n * Get volume category according to medical type definitions\n * @param {number} volume - Volume in ml\n * @returns {'small'|'moderate'|'large'|'massive'} Volume category\n */\nfunction getVolumeCategory(volume) {\n  try {\n    // Type safety validation\n    TypeChecker.ensureType(volume, 'number', 'volume for categorization');\n\n    if (volume < 0) {\n      throw new TypeError('Volume cannot be negative for categorization');\n    }\n\n    const thresholds = MEDICAL_CONSTANTS.VOLUME_THRESHOLDS;\n\n    if (volume < thresholds.SMALL) {\n      return 'small';\n    }\n    if (volume < thresholds.MODERATE) {\n      return 'moderate';\n    }\n    if (volume < thresholds.LARGE) {\n      return 'large';\n    }\n    return 'massive';\n  } catch (error) {\n    // Fallback to 'small' for safety\n    return 'small';\n  }\n}\n\n/**\n * Format volume for display with appropriate precision\n * @param {number} volume - Volume in ml\n * @returns {string} Formatted volume string\n */\nexport function formatVolumeDisplay(volume) {\n  if (volume < 1) {\n    return '<1 ml';\n  }\n  if (volume < 10) {\n    return `${volume.toFixed(1)} ml`;\n  }\n  return `${Math.round(volume)} ml`;\n}\n"],"names":["LAMBDA","B0","B_GFAP","B_FAST","MU_G","SIG_G","MU_F","SIG_F","A_PLATT","B_PLATT","FINAL_THRESHOLD","NUMERIC_EPS","MIN_FAST_ED","MAX_FAST_ED","yeoJohnson","x","lambda","standardize","value","mean","std","logistic","validateInputs","gfap","fasted","numGfap","numFasted","lvoProbability","validated","clampedFasted","gfapTransformed","gfapStandardized","fastedStandardized","logit","calibratedLogit","lvoClass","APIError","message","status","url","MedicalAPIError","formatDriversFromDict","drivers","predictionType","positive","negative","label","weight","a","b","clientHelpers","defaultValue","parsed","payload","normalized","key","endpoint","endpointType","controller","timeout","timeoutId","normalizedPayload","response","errorText","result","error","moduleType","API_URLS","predictComaIch","apiError","predictLimitedIch","predictLVO","retryCount","gfapValue","fastEdScore","probability","classification","localError","predictFullStroke","isLocalPreview","fullStrokeResponse","ichResult","lvoResult","lvoError","mockData","DEV_CONFIG","ichPrediction","lvoPrediction","validatePatientData","data","errors","warnings","validateICHRiskResult","isPatientData","isICHRiskResult","TypeChecker","expectedType","fieldName","isValid","actualType","range","min","max","estimateVolumeFromGFAP","v","e","estimateMortalityFromVolume","volume","formatVolumeDisplay"],"mappings":"gGAWA,MAAMA,EAAS,SACTC,EAAK,SACLC,EAAS,QACTC,EAAS,SAGTC,EAAO,GACPC,EAAQ,EACRC,EAAO,SACPC,EAAQ,SAGRC,EAAU,QACVC,EAAU,UAGVC,EAAkB,QAGlBC,EAAc,MAEdC,EAAc,EACdC,EAAc,GAKpB,SAASC,EAAWC,EAAGC,EAAQ,CAC7B,OAAI,KAAK,IAAIA,CAAM,EAAIL,EACd,KAAK,IAAII,EAAI,CAAG,IAEhBA,EAAI,IAAQC,EAAS,GAAOA,CACvC,CAKA,SAASC,EAAYC,EAAOC,EAAMC,EAAK,CACrC,OAAQF,EAAQC,GAAQC,CAC1B,CAKA,SAASC,EAASN,EAAG,CACnB,OAAIA,EAAI,IACC,EAELA,EAAI,KACC,EAEF,GAAO,EAAM,KAAK,IAAI,CAACA,CAAC,EACjC,CAKA,SAASO,EAAeC,EAAMC,EAAQ,CAEpC,GAAID,GAAQ,KACV,MAAM,IAAI,MAAM,kBAAkB,EAEpC,GAAIC,GAAU,KACZ,MAAM,IAAI,MAAM,oBAAoB,EAItC,MAAMC,EAAU,OAAOF,CAAI,EACrBG,EAAY,OAAOF,CAAM,EAG/B,GAAI,CAAC,OAAO,SAASC,CAAO,EAC1B,MAAM,IAAI,MAAM,8BAA8B,EAEhD,GAAI,CAAC,OAAO,SAASC,CAAS,EAC5B,MAAM,IAAI,MAAM,gCAAgC,EAIlD,GAAID,EAAU,EACZ,MAAM,IAAI,MAAM,iCAAiC,EAGnD,MAAO,CAAE,KAAMA,EAAS,OAAQC,CAAS,CAC3C,CAKO,SAASC,EAAeJ,EAAMC,EAAQ,CAC3C,MAAMI,EAAYN,EAAeC,EAAMC,CAAM,EAGvCK,EAAgB,KAAK,IAAIjB,EAAa,KAAK,IAAIC,EAAae,EAAU,MAAM,CAAC,EAG7EE,EAAkBhB,EAAWc,EAAU,KAAM5B,CAAM,EACnD+B,EAAmBd,EAAYa,EAAiB1B,EAAMC,CAAK,EAC3D2B,EAAqBf,EAAYY,EAAevB,EAAMC,CAAK,EAG3D0B,EAAQhC,EAAKC,EAAS6B,EAAmB5B,EAAS6B,EAGlDE,EAAkB1B,EAAUyB,EAAQxB,EAG1C,OAAOY,EAASa,CAAe,CACjC,CAKO,SAASC,EAASZ,EAAMC,EAAQ,CAErC,OADoBG,EAAeJ,EAAMC,CAAM,GACzBd,EAAkB,EAAI,CAC9C,CC1GO,MAAM0B,UAAiB,KAAM,CAClC,YAAYC,EAASC,EAAQC,EAAK,CAChC,MAAMF,CAAO,EACb,KAAK,KAAO,WACZ,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACF,CAGO,MAAMC,UAAwBJ,CAAS,CAC5C,YAAYC,EAASC,EAAQC,EAAK,CAChC,MAAMF,EAASC,EAAQC,CAAG,EAC1B,KAAK,KAAO,iBACd,CACF,CAGA,SAASE,EAAsBC,EAASC,EAAgB,CACtD,GAAI,CAACD,GAAW,OAAOA,GAAY,SACjC,OAAO,KAGT,MAAME,EAAW,CAAA,EACXC,EAAW,CAAA,EAEjB,cAAO,QAAQH,CAAO,EAAE,QAAQ,CAAC,CAACI,EAAOC,CAAM,IAAM,CAC/C,OAAOA,GAAW,WAChBA,EAAS,EACXH,EAAS,KAAK,CAAE,MAAAE,EAAO,OAAAC,CAAM,CAAE,EACtBA,EAAS,GAClBF,EAAS,KAAK,CAAE,MAAAC,EAAO,OAAQ,KAAK,IAAIC,CAAM,EAAG,EAGvD,CAAC,EAGDH,EAAS,KAAK,CAACI,EAAGC,IAAMA,EAAE,OAASD,EAAE,MAAM,EAC3CH,EAAS,KAAK,CAACG,EAAGC,IAAMA,EAAE,OAASD,EAAE,MAAM,EAEpC,CACL,KAAM,kBACN,MAAO,QACP,SAAAJ,EACA,SAAAC,EACA,KAAM,CAAA,CACV,CACA,CAGA,MAAMK,EAAgB,CACpB,eAAgB,CAAChC,EAAOiC,EAAe,IAAM,CAC3C,MAAMC,EAAS,WAAWlC,CAAK,EAC/B,OAAO,MAAMkC,CAAM,EAAID,EAAeC,CACxC,EAEA,kBAAoBC,GAAY,CAC9B,MAAMC,EAAa,CAAE,GAAGD,CAAO,EAC/B,cAAO,KAAKC,CAAU,EAAE,QAASC,GAAQ,CACnCD,EAAWC,CAAG,IAAM,QAAUD,EAAWC,CAAG,IAAM,GACpDD,EAAWC,CAAG,EAAI,GACTD,EAAWC,CAAG,IAAM,SAAWD,EAAWC,CAAG,IAAM,MAC5DD,EAAWC,CAAG,EAAI,EAEtB,CAAC,EACMD,CACT,EAEA,MAAM,YAAYE,EAAUH,EAASI,EAAe,UAAW,CAC7D,QAAQ,IAAI,gBAAgBA,CAAY,eAAgBD,CAAQ,EAChE,QAAQ,IAAI,iBAAkBH,CAAO,EAErC,GAAI,CACF,MAAMK,EAAa,IAAI,gBACjBC,EAAUH,EAAS,SAAS,aAAa,EAAI,KAAQ,IACrDI,EAAY,WAAW,IAAMF,EAAW,MAAK,EAAIC,CAAO,EAExDE,EAAoB,KAAK,kBAAkBR,CAAO,EAElDS,EAAW,MAAM,MAAMN,EAAU,CACrC,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,OAAQ,kBAClB,EACQ,KAAM,KAAK,UAAUK,CAAiB,EACtC,OAAQH,EAAW,OACnB,KAAM,MACd,CAAO,EAID,GAFA,aAAaE,CAAS,EAElB,CAACE,EAAS,GAAI,CAChB,MAAMC,EAAY,MAAMD,EAAS,KAAI,EAAG,MAAM,IAAM,eAAe,EACnE,MAAM,IAAItB,EACR,uBAAuBsB,EAAS,MAAM,IAAIA,EAAS,UAAU,MAAMC,CAAS,GAC5ED,EAAS,OACTN,CACV,CACM,CAEA,MAAMQ,EAAS,MAAMF,EAAS,KAAI,EAClC,eAAQ,IAAI,SAASL,CAAY,aAAcO,CAAM,EACrD,QAAQ,IAAI,SAASP,CAAY,kBAAmB,OAAO,KAAKO,CAAM,CAAC,EACvE,QAAQ,IAAI,SAASP,CAAY,cAAe,OAAO,KAAKO,CAAM,EAAE,CAAC,CAAC,EACtE,QAAQ,IAAI,SAASP,CAAY,gBAAiBO,EAAO,OAAO,KAAKA,CAAM,EAAE,CAAC,CAAC,CAAC,EAChF,QAAQ,IAAI,SAASP,CAAY,gBAAiBO,EAAO,WAAW,EACpE,QAAQ,IAAI,SAASP,CAAY,oBAAqBO,EAAO,eAAe,EAGxE,CAACA,EAAO,aAAeA,EAAO,kBAAoB,SACpDA,EAAO,YAAcA,EAAO,gBAC5B,QAAQ,IAAI,SAASP,CAAY,gDAAiDO,EAAO,WAAW,GAG/FA,CACT,OAASC,EAAO,CACd,MAAIA,EAAM,OAAS,cACjB,QAAQ,KAAK,SAASR,CAAY,kBAAkB,EAC9C,IAAIjB,EAAgB,yBAAyB,QAAU,GAAI,IAAK,IAAKgB,CAAQ,GAGjFS,aAAiBzB,EACbyB,GAGR,QAAQ,MAAM,SAASR,CAAY,mBAAoBQ,CAAK,EACtD,IAAIzB,EACR,kBAAkByB,EAAM,OAAO,GAC/B,EACAT,CACR,EACI,CACF,EAEA,gBAAiB,KAAO,CAAE,SAAU,EAAG,OAAQ,EAAG,gBAAiB,IACnE,kBAAmB,IAAM,QAAQ,IAAI,mCAAmC,EAExE,MAAM,QAAQU,EAAYb,EAAS,CAQjC,MAAMG,EAPc,CAClB,SAAUW,EAAS,SACnB,YAAaA,EAAS,QACtB,YAAaA,EAAS,YACtB,IAAKA,EAAS,cACpB,EAEiCD,CAAU,EACvC,GAAI,CAACV,EACH,MAAM,IAAIhB,EAAgB,wBAAwB0B,CAAU,GAAI,IAAK,SAAS,EAGhF,OAAO,MAAM,KAAK,YAAYV,EAAUH,EAASa,CAAU,CAC7D,CACF,EAoDO,eAAeE,EAAef,EAAS,CAC5C,GAAI,CACF,OAAO,MAAMH,EAAc,QAAQ,WAAYG,CAAO,CACxD,OAASY,EAAO,CAEd,GAAIA,aAAiBzB,EAAiB,CACpC,MAAM6B,EAAW,IAAI,MAAMJ,EAAM,OAAO,EACxC,MAAAI,EAAS,KAAO,WAChBA,EAAS,OAASJ,EAAM,OACxBI,EAAS,IAAMJ,EAAM,IACfI,CACR,CACA,MAAMJ,CACR,CACF,CAOO,eAAeK,EAAkBjB,EAAS,CAC/C,GAAI,CACF,OAAO,MAAMH,EAAc,QAAQ,cAAeG,CAAO,CAC3D,OAASY,EAAO,CACd,GAAIA,aAAiBzB,EAAiB,CACpC,MAAM6B,EAAW,IAAI,MAAMJ,EAAM,OAAO,EACxC,MAAAI,EAAS,KAAO,WAChBA,EAAS,OAASJ,EAAM,OACxBI,EAAS,IAAMJ,EAAM,IACfI,CACR,CACA,MAAMJ,CACR,CACF,CAQO,eAAeM,EAAWlB,EAASmB,EAAa,EAAG,CAGxD,GAFA,QAAQ,IAAI,wCAAyCnB,CAAO,EAExD,CAACA,EAAQ,YAAc,CAACA,EAAQ,cAClC,MAAM,IAAIb,EACR,4DACA,IACA2B,EAAS,cACf,EAGE,QAAQ,IAAI,kCAAkC,EAE9C,GAAI,CAEF,QAAQ,IAAI,wCAAwC,EACpD,MAAMH,EAAS,MAAMd,EAAc,QAAQ,MAAOG,CAAO,EACzD,eAAQ,IAAI,qCAAsCW,CAAM,EACjDA,CACT,OAASC,EAAO,CACd,QAAQ,KAAK,6DAA8DA,EAAM,OAAO,EACxF,QAAQ,IAAI,mCAAmC,EAE/C,GAAI,CACF,MAAMQ,EAAY,WAAWpB,EAAQ,UAAU,EACzCqB,EAAc,SAASrB,EAAQ,aAAa,EAElD,GAAI,MAAMoB,CAAS,GAAK,MAAMC,CAAW,EACvC,MAAM,IAAI,MAAM,gCAAgC,EAGlD,MAAMC,EAAchD,EAAe8C,EAAWC,CAAW,EACnDE,EAAiBzC,EAASsC,EAAWC,CAAW,EAEhDhC,EAAU,CACd,KAAM,qBACN,MAAO,0BACP,SAAU,CACR,CAAE,MAAO,iBAAkB,OAAQ+B,EAAY,IAAM,GAAM,EAAG,EAC9D,CAAE,MAAO,gBAAiB,OAAQC,EAAc,EAAG,CAC7D,EAAU,KAAK,CAAC1B,EAAG,IAAM,KAAK,IAAI,EAAE,MAAM,EAAI,KAAK,IAAIA,EAAE,MAAM,CAAC,EACxD,SAAU,CAAA,EACV,KAAM,CACJ,UAAW2B,EAAc,GAAM,OAASA,EAAc,GAAM,WAAa,MACzE,eAAgB,IAAIA,EAAc,KAAK,QAAQ,CAAC,CAAC,sBAAsBC,IAAmB,EAAI,WAAa,UAAU,GAC/H,CACA,EAEM,MAAO,CACL,YAAAD,EACA,QAAAjC,EACA,WAAYiC,EAAc,GAAM,GAAMA,EAAc,GAAM,GAAM,GAChE,OAAQ,4CACR,eAAgB,IAAIA,EAAc,KAAK,QAAQ,CAAC,CAAC,mCAAmCF,CAAS,gBAAgBC,CAAW,EAChI,CACI,OAASG,EAAY,CACnB,cAAQ,KAAK,oCAAqCA,EAAW,OAAO,EAC9D,IAAIrC,EACR,0BAA0ByB,EAAM,OAAO,GACvCA,EAAM,QAAU,IAChBE,EAAS,cACjB,CACI,CACF,CACF,CAQO,eAAeW,EAAkBzB,EAASmB,EAAa,EAAG,CAC/D,QAAQ,IAAI,+CAAgDnB,CAAO,EACnE,QAAQ,IAAI,0BAA2B0B,GAAgB,EAEvD,GAAI,CAEF,MAAMC,EAAqB,MAAM9B,EAAc,QAAQ,cAAeG,CAAO,EAC7E,QAAQ,IAAI,kCAAmC2B,CAAkB,EAGjE,MAAMC,EAAYD,EAAmB,gBAAkB,CAAA,EACvD,QAAQ,IAAI,4BAA6BC,CAAS,EAGlD,IAAIC,EAAY,KAChB,GAAI,CACF,QAAQ,IAAI,+DAA+D,EAC3EA,EAAY,MAAMX,EAAWlB,CAAO,EACpC,QAAQ,IAAI,oDAAoD,CAClE,OAAS8B,EAAU,CACjB,QAAQ,KAAK,sCAAuCA,CAAQ,EAGxDF,EAAU,eACZC,EAAY,CACV,YAAaD,EAAU,eAAe,aAAe,EACrD,QAASA,EAAU,eAAe,SAAW,KAC7C,WAAYA,EAAU,eAAe,YAAc,GACnD,OAAQ,4BAClB,EAGQC,EAAY,MAAMX,EAAWlB,CAAO,CAExC,CAEA,MAAO,CACL,IAAK,CACH,YAAa4B,EAAU,YACvB,QAASA,EAAU,QAAUxC,EAAsBwC,EAAU,QAAS,KAAK,EAAIA,EAAU,QACzF,WAAYA,EAAU,WACtB,OAAQA,EAAU,MAC1B,EACM,IAAKC,CACX,CACE,OAASjB,EAAO,CAGd,GAFA,QAAQ,MAAM,iCAAkCA,CAAK,EAEjDA,EAAM,SAAW,KAAOO,EAAa,EACvC,eAAQ,IAAI,sDAAsD,EAC3DM,EAAkBzB,EAASmB,EAAa,CAAC,EAIlD,GAAIO,EAAc,EAAI,CACpB,MAAMK,EAAWC,EAAW,iBAAiB,YACvCC,EAAgBF,EAAS,gBAAkB,CAAA,EAC3CG,EAAgBH,EAAS,gBAAkB,CAAA,EAEjD,MAAO,CACL,IAAK,CACH,YAAalC,EAAc,eAAeoC,EAAc,YAAa,CAAC,EACtE,QAASA,EAAc,SAAW,KAClC,WAAYpC,EAAc,eAAeoC,EAAc,WAAY,GAAI,EACvE,OAAQ,oBAClB,EACQ,IAAK,CACH,YAAapC,EAAc,eAAeqC,EAAc,YAAa,CAAC,EACtE,QAASA,EAAc,SAAW,KAClC,WAAYrC,EAAc,eAAeqC,EAAc,WAAY,GAAI,EACvE,OAAQ,oBAClB,CACA,CACI,CAEA,MAAM,IAAI/C,EACR,qCAAqCyB,EAAM,OAAO,GAClDA,EAAM,OACNE,EAAS,WACf,CACE,CACF,CAMA,SAASY,GAAiB,CACxB,MAAO,CAAC,YAAa,YAAa,SAAS,EAAE,SAAS,OAAO,SAAS,QAAQ,CAChF,CChTO,SAASS,EAAoBC,EAAM,CACxC,MAAMC,EAAS,CAAA,EACTC,EAAW,CAAA,EAEjB,MAAI,CAACF,GAAQ,OAAOA,GAAS,UAC3BC,EAAO,KAAK,gCAAgC,EACrC,CAAE,QAAS,GAAO,OAAAA,EAAQ,SAAAC,CAAQ,KAIvC,OAAOF,EAAK,KAAQ,UAAYA,EAAK,IAAM,GAAKA,EAAK,IAAM,MAC7DC,EAAO,KAAK,wCAAwC,EAGjD,CAAC,OAAQ,SAAU,OAAO,EAAE,SAASD,EAAK,MAAM,GACnDC,EAAO,KAAK,6CAA6C,GAGvD,OAAOD,EAAK,MAAS,UAAYA,EAAK,KAAO,IAAMA,EAAK,KAAO,QACjEC,EAAO,KAAK,kDAAkD,EAI5DD,EAAK,QAAU,SAAc,OAAOA,EAAK,OAAU,UAAYA,EAAK,MAAQ,GAAKA,EAAK,MAAQ,KAChGC,EAAO,KAAK,yCAAyC,EAGnDD,EAAK,MAAQ,SAAc,OAAOA,EAAK,KAAQ,UAAYA,EAAK,IAAM,GAAKA,EAAK,IAAM,KACxFC,EAAO,KAAK,uCAAuC,EAGjDD,EAAK,MAAQ,SAAc,OAAOA,EAAK,KAAQ,UAAYA,EAAK,IAAM,IAAMA,EAAK,IAAM,MACzFE,EAAS,KAAK,qDAAqD,EAGjEF,EAAK,MAAQ,SAAc,OAAOA,EAAK,KAAQ,UAAYA,EAAK,IAAM,IAAMA,EAAK,IAAM,MACzFE,EAAS,KAAK,sDAAsD,EAG/D,CAAE,QAASD,EAAO,SAAW,EAAG,OAAAA,EAAQ,SAAAC,CAAQ,EACzD,CAOO,SAASC,EAAsB5B,EAAQ,CAC5C,MAAM0B,EAAS,CAAA,EACTC,EAAW,CAAA,EAEjB,MAAI,CAAC3B,GAAU,OAAOA,GAAW,UAC/B0B,EAAO,KAAK,mCAAmC,EACxC,CAAE,QAAS,GAAO,OAAAA,EAAQ,SAAAC,CAAQ,KAGvC,OAAO3B,EAAO,aAAgB,UAAYA,EAAO,YAAc,GAAKA,EAAO,YAAc,IAC3F0B,EAAO,KAAK,8CAA8C,GAGxD,OAAO1B,EAAO,YAAe,UAAYA,EAAO,WAAa,GAAKA,EAAO,WAAa,MACxF0B,EAAO,KAAK,+CAA+C,EAGxD,CAAC,MAAO,WAAY,OAAQ,UAAU,EAAE,SAAS1B,EAAO,SAAS,GACpE0B,EAAO,KAAK,6DAA6D,GAGvE,CAAC1B,EAAO,WAAa,CAAC,KAAK,MAAMA,EAAO,SAAS,IACnD0B,EAAO,KAAK,2CAA2C,EAGlD,CAAE,QAASA,EAAO,SAAW,EAAG,OAAAA,EAAQ,SAAAC,CAAQ,EACzD,CAWO,SAASE,EAAc3E,EAAO,CAEnC,OADmBsE,EAAoBtE,CAAK,EAC1B,OACpB,CAOO,SAAS4E,EAAgB5E,EAAO,CAErC,OADmB0E,EAAsB1E,CAAK,EAC5B,OACpB,CAsCO,MAAM6E,CAAY,CAQvB,OAAO,WAAW7E,EAAO8E,EAAcC,EAAW,CAChD,IAAIC,EAAU,GACVC,EAAa,OAAOjF,EAExB,OAAQ8E,EAAY,CAClB,IAAK,cACHE,EAAUL,EAAc3E,CAAK,EAC7BiF,EAAa,sBACb,MACF,IAAK,gBACHD,EAAUJ,EAAgB5E,CAAK,EAC/BiF,EAAa,wBACb,MACF,IAAK,SACHD,EAAU,OAAOhF,GAAU,UAAY,CAAC,MAAMA,CAAK,EACnD,MACF,IAAK,SACHgF,EAAU,OAAOhF,GAAU,SAC3B,MACF,IAAK,UACHgF,EAAU,OAAOhF,GAAU,UAC3B,MACF,QACEgF,EAAU,OAAOhF,IAAU8E,CACnC,CAEI,GAAI,CAACE,EACH,MAAM,IAAI,UACR,iBAAiBD,CAAS,cAAcD,CAAY,SAASG,CAAU,qDAE/E,CAEE,CASA,OAAO,YAAYjF,EAAOkF,EAAOH,EAAW,CAC1C,KAAK,WAAW/E,EAAO,SAAU+E,CAAS,EAC1C,KAAM,CAACI,EAAKC,CAAG,EAAIF,EAEnB,GAAIlF,EAAQmF,GAAOnF,EAAQoF,EACzB,MAAM,IAAI,WACR,kBAAkBL,CAAS,WAAW/E,CAAK,oBAAoBmF,CAAG,QAAQC,CAAG,qDAErF,CAEE,CACF,CCtDO,SAASC,EAAuBhF,EAAM,CAC3C,GAAI,CACF,MAAMiF,EAAI,KAAK,IAAI,EAAG,KAAO,MAAS,MAAS,KAAK,MAAM,KAAK,IAAI,EAAG,KAAK,IAAIjF,EAAM,GAAK,CAAC,CAAC,EAAE,EAC9F,OAAO,OAAO,SAASiF,CAAC,EAAIA,EAAI,CAClC,OAAQC,EAAA,CACN,MAAO,EACT,CACF,CAOO,SAASC,EAA4BC,EAAQ,CAClD,MAAI,CAAC,OAAO,SAASA,CAAM,GAAKA,GAAU,EACjC,QAELA,GAAU,GACL,UAELA,GAAU,GACL,SAELA,GAAU,GACL,SAELA,GAAU,GACL,SAEF,OACT,CA2WO,SAASC,EAAoBD,EAAQ,CAC1C,OAAIA,EAAS,EACJ,QAELA,EAAS,GACJ,GAAGA,EAAO,QAAQ,CAAC,CAAC,MAEtB,GAAG,KAAK,MAAMA,CAAM,CAAC,KAC9B"}