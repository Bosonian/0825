{"version":3,"file":"enterprise-features-DIAO-rWl.js","sources":["../../src/security/html-sanitizer.js","../../src/security/environment.js","../../src/utils/error-handler.js","../../src/utils/medical-logger.js","../../src/security/data-encryption.js","../../src/workers/sw-manager.js","../../src/performance/medical-cache.js","../../src/sync/medical-sync-manager.js","../../src/workers/medical-service-worker.js"],"sourcesContent":["/**\n * HTML Sanitization Utilities for XSS Prevention\n * iGFAP Stroke Triage Assistant - Enterprise Security\n *\n * Provides secure HTML sanitization to prevent XSS attacks\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\n/**\n * Allowed HTML tags for medical content\n */\nconst ALLOWED_TAGS = [\n  'p', 'div', 'span', 'br', 'strong', 'b', 'em', 'i', 'u',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n  'ul', 'ol', 'li',\n  'table', 'tr', 'td', 'th', 'thead', 'tbody',\n  'small', 'sub', 'sup',\n  'button', 'input', 'form', 'label', 'select', 'option', 'textarea',\n  'a', 'img', 'canvas', 'svg', 'path', 'circle', 'rect', 'line', 'g', 'text',\n];\n\n/**\n * Allowed attributes for HTML tags\n */\nconst ALLOWED_ATTRIBUTES = {\n  div: ['class', 'id', 'style', 'data-id', 'data-action', 'data-value', 'data-module', 'data-target'],\n  span: ['class', 'id', 'style', 'data-id'],\n  p: ['class', 'style'],\n  strong: ['class'],\n  b: ['class'],\n  em: ['class'],\n  i: ['class'],\n  table: ['class'],\n  tr: ['class'],\n  td: ['class', 'colspan', 'rowspan'],\n  th: ['class', 'colspan', 'rowspan'],\n  ul: ['class'],\n  ol: ['class'],\n  li: ['class'],\n  h1: ['class'],\n  h2: ['class'],\n  h3: ['class'],\n  h4: ['class'],\n  h5: ['class'],\n  h6: ['class'],\n  small: ['class'],\n  button: ['class', 'id', 'type', 'data-action', 'data-value', 'data-target', 'disabled'],\n  input: ['class', 'id', 'type', 'name', 'value', 'placeholder', 'required', 'data-module', 'autocomplete', 'readonly', 'checked', 'min', 'max', 'step', 'aria-describedby'],\n  form: ['class', 'id', 'data-module', 'action', 'method'],\n  label: ['class', 'for'],\n  select: ['class', 'id', 'name', 'required'],\n  option: ['value', 'selected'],\n  textarea: ['class', 'id', 'name', 'placeholder', 'required', 'rows', 'cols'],\n  a: ['href', 'target', 'class', 'id'],\n  img: ['src', 'alt', 'class', 'id', 'width', 'height'],\n  canvas: ['class', 'id', 'width', 'height'],\n  svg: ['class', 'id', 'width', 'height', 'viewBox', 'xmlns', 'style'],\n  path: ['d', 'fill', 'stroke', 'stroke-width', 'class'],\n  circle: ['cx', 'cy', 'r', 'fill', 'stroke', 'stroke-width', 'class', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'transform'],\n  rect: ['x', 'y', 'width', 'height', 'fill', 'stroke', 'stroke-width', 'class'],\n  line: ['x1', 'y1', 'x2', 'y2', 'stroke', 'stroke-width', 'class'],\n  g: ['class', 'transform'],\n  text: ['x', 'y', 'text-anchor', 'font-family', 'font-size', 'font-weight', 'fill', 'class', 'style', 'dominant-baseline'],\n};\n\n/**\n * Allowed CSS properties for style attributes\n */\nconst ALLOWED_STYLES = [\n  'color', 'background-color', 'font-size', 'font-weight',\n  'text-align', 'margin', 'padding', 'border',\n  'display', 'visibility', 'opacity', 'pointer-events', 'overflow',\n];\n\n/**\n * Sanitize HTML content to prevent XSS attacks\n * @param {string} html - Raw HTML content\n * @param {Object} options - Sanitization options\n * @returns {string} - Sanitized HTML\n */\nexport function sanitizeHTML(html, options = {}) {\n  if (typeof html !== 'string') {\n    return '';\n  }\n\n  // Basic XSS pattern detection\n  if (containsXSSPatterns(html)) {\n    throw new Error('Potentially malicious content detected');\n  }\n\n  // Use browser's DOMParser for parsing\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(html, 'text/html');\n\n  // Check for parsing errors\n  const parserError = doc.querySelector('parsererror');\n  if (parserError) {\n    throw new Error('Invalid HTML content');\n  }\n\n  // Sanitize the document\n  sanitizeNode(doc.body, options);\n\n  return doc.body.innerHTML;\n}\n\n/**\n * Check for common XSS patterns\n * @param {string} html - HTML content to check\n * @returns {boolean} - True if XSS patterns detected\n */\nfunction containsXSSPatterns(html) {\n  const xssPatterns = [\n    /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n    /javascript:/gi,\n    /on\\w+\\s*=/gi,\n    /<iframe\\b(?![^>]*src=[\"'][^\"']*\\/0925\\/)/gi, // Allow our own iframes\n    /<object\\b/gi,\n    /<embed\\b/gi,\n    /<meta\\b/gi,\n    /<link\\b(?![^>]*rel=[\"']manifest)/gi, // Allow manifest links\n  ];\n\n  return xssPatterns.some((pattern) => pattern.test(html));\n}\n\n/**\n * Recursively sanitize DOM nodes\n * @param {Node} node - DOM node to sanitize\n * @param {Object} options - Sanitization options\n */\nfunction sanitizeNode(node, options) {\n  const nodesToRemove = [];\n\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes[i];\n\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      const tagName = child.tagName.toLowerCase();\n\n      // Remove disallowed tags\n      if (!ALLOWED_TAGS.includes(tagName)) {\n        nodesToRemove.push(child);\n        continue;\n      }\n\n      // Sanitize attributes\n      sanitizeAttributes(child);\n\n      // Recursively sanitize children\n      sanitizeNode(child, options);\n    } else if (child.nodeType === Node.TEXT_NODE) {\n      // Text nodes are already safe - they cannot contain HTML markup\n      // No escaping needed; the browser treats them as literal text\n      // Leave text content as-is\n    } else {\n      // Remove other node types (comments, etc.)\n      nodesToRemove.push(child);\n    }\n  }\n\n  // Remove flagged nodes\n  nodesToRemove.forEach((nodeToRemove) => {\n    node.removeChild(nodeToRemove);\n  });\n}\n\n/**\n * Sanitize element attributes\n * @param {Element} element - Element to sanitize\n */\nfunction sanitizeAttributes(element) {\n  const tagName = element.tagName.toLowerCase();\n  const allowedAttrs = ALLOWED_ATTRIBUTES[tagName] || [];\n  const attrsToRemove = [];\n\n  // Check all attributes\n  for (let i = 0; i < element.attributes.length; i++) {\n    const attr = element.attributes[i];\n    const attrName = attr.name.toLowerCase();\n\n    // Allow any data-* attribute for component islands and UI hooks\n    const isDataAttr = attrName.startsWith('data-');\n\n    if (!allowedAttrs.includes(attrName) && !isDataAttr) {\n      attrsToRemove.push(attrName);\n    } else if (attrName === 'style') {\n      // Sanitize style attribute\n      element.setAttribute('style', sanitizeStyleAttribute(attr.value));\n    } else {\n      // Escape attribute value\n      element.setAttribute(attrName, escapeAttributeValue(attr.value));\n    }\n  }\n\n  // Remove disallowed attributes\n  attrsToRemove.forEach((attrName) => {\n    element.removeAttribute(attrName);\n  });\n}\n\n/**\n * Sanitize CSS in style attributes\n * @param {string} styleValue - CSS style value\n * @returns {string} - Sanitized style value\n */\nfunction sanitizeStyleAttribute(styleValue) {\n  if (!styleValue) {\n    return '';\n  }\n\n  const styles = styleValue.split(';');\n  const sanitizedStyles = [];\n\n  styles.forEach((style) => {\n    const [property, value] = style.split(':').map((s) => s.trim());\n\n    if (property && value && ALLOWED_STYLES.includes(property.toLowerCase())) {\n      // Basic CSS injection prevention\n      if (!value.includes('javascript:') && !value.includes('expression(')) {\n        sanitizedStyles.push(`${property}: ${value}`);\n      }\n    }\n  });\n\n  return sanitizedStyles.join('; ');\n}\n\n/**\n * Escape text content to prevent XSS\n * @param {string} text - Text content\n * @returns {string} - Escaped text\n */\nfunction escapeTextContent(text) {\n  if (!text) {\n    return '';\n  }\n\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/\\//g, '&#x2F;');\n}\n\n/**\n * Escape attribute values\n * @param {string} value - Attribute value\n * @returns {string} - Escaped value\n */\nfunction escapeAttributeValue(value) {\n  if (!value) {\n    return '';\n  }\n\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n}\n\n/**\n * Safe innerHTML replacement\n * @param {Element} element - Target element\n * @param {string} html - HTML content to set\n * @param {Object} options - Sanitization options\n */\nexport function safeSetInnerHTML(element, html, options = {}) {\n  if (!element || typeof html !== 'string') {\n    return;\n  }\n\n  try {\n    const sanitizedHTML = sanitizeHTML(html, options);\n    element.innerHTML = sanitizedHTML;\n  } catch (error) {\n    // Fallback to text content on sanitization error\n    element.textContent = html.replace(/<[^>]*>/g, '');\n    throw new Error(`HTML sanitization failed: ${error.message}`);\n  }\n}\n\n/**\n * Create safe HTML string for medical content\n * @param {string} template - HTML template\n * @param {Object} data - Data to interpolate\n * @returns {string} - Safe HTML string\n */\nexport function createSafeHTML(template, data = {}) {\n  if (typeof template !== 'string') {\n    return '';\n  }\n\n  // Basic template interpolation with escaping\n  let html = template;\n\n  Object.keys(data).forEach((key) => {\n    const placeholder = new RegExp(`\\\\{\\\\{\\\\s*${key}\\\\s*\\\\}\\\\}`, 'g');\n    const value = data[key];\n\n    if (typeof value === 'string') {\n      html = html.replace(placeholder, escapeTextContent(value));\n    } else if (typeof value === 'number') {\n      html = html.replace(placeholder, value.toString());\n    } else {\n      html = html.replace(placeholder, '');\n    }\n  });\n\n  return sanitizeHTML(html);\n}\n\n/**\n * Validate and sanitize medical report content\n * @param {string} content - Medical report content\n * @returns {string} - Sanitized content\n */\nexport function sanitizeMedicalContent(content) {\n  const options = {\n    allowMedicalTags: true,\n    preserveFormatting: true,\n  };\n\n  return sanitizeHTML(content, options);\n}\n","/**\n * Secure Environment Configuration Manager\n * Provides secure access to environment variables with validation and fallbacks\n */\n\nclass EnvironmentConfig {\n  constructor() {\n    this.config = {};\n    this.isInitialized = false;\n    this.initializeConfig();\n  }\n\n  initializeConfig() {\n    try {\n      // Load environment variables (for Node.js environments)\n      if (typeof process !== 'undefined' && process.env) {\n        this.config = { ...process.env };\n      }\n\n      // For client-side, use secure storage or runtime configuration\n      if (typeof window !== 'undefined') {\n        this.loadClientConfig();\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.warn('Failed to initialize environment config:', error.message);\n      this.loadDefaults();\n    }\n  }\n\n  loadClientConfig() {\n    // Client-side configuration with security considerations\n    // Use runtime configuration instead of build-time injection for sensitive data\n    const clientConfig = {\n      // Default values that are safe to expose\n      NODE_ENV: 'production',\n      DEBUG_MODE: false,\n      MOCK_API_ENABLED: false,\n      LOG_LEVEL: 'info',\n\n      // Session configuration (safe defaults)\n      SESSION_TIMEOUT_HOURS: 4,\n      BCRYPT_SALT_ROUNDS: 12,\n      ENCRYPTION_KEY_LENGTH: 256,\n\n      // Rate limiting\n      MAX_AUTH_ATTEMPTS: 5,\n      RATE_LIMIT_WINDOW_MS: 900000, // 15 minutes\n\n      // Medical compliance\n      ENABLE_DATA_ENCRYPTION: true,\n      ENABLE_AUDIT_TRAIL: true,\n      DATA_RETENTION_DAYS: 90,\n\n      // GCP configuration (non-sensitive)\n      GCP_PROJECT_ID: 'igfap-452720',\n      GCP_REGION: 'europe-west3',\n    };\n\n    // Merge with any runtime configuration\n    this.config = { ...this.config, ...clientConfig };\n  }\n\n  loadDefaults() {\n    // Secure fallback configuration\n    this.config = {\n      NODE_ENV: 'development',\n      DEBUG_MODE: false,\n      MOCK_API_ENABLED: true,\n      LOG_LEVEL: 'warn',\n      SESSION_TIMEOUT_HOURS: 4,\n      BCRYPT_SALT_ROUNDS: 12,\n      MAX_AUTH_ATTEMPTS: 3,\n      RATE_LIMIT_WINDOW_MS: 900000,\n      ENABLE_DATA_ENCRYPTION: true,\n      ENABLE_AUDIT_TRAIL: true,\n      DATA_RETENTION_DAYS: 30,\n      GCP_PROJECT_ID: 'igfap-452720',\n      GCP_REGION: 'europe-west3',\n    };\n    this.isInitialized = true;\n  }\n\n  /**\n   * Get environment variable with validation and fallback\n   * @param {string} key - Environment variable key\n   * @param {*} defaultValue - Default value if not found\n   * @param {string} type - Expected type (string, number, boolean)\n   * @returns {*} Environment variable value\n   */\n  get(key, defaultValue = null, type = 'string') {\n    if (!this.isInitialized) {\n      this.initializeConfig();\n    }\n\n    let value = this.config[key];\n\n    // Use default if value is not found\n    if (value === undefined || value === null || value === '') {\n      value = defaultValue;\n    }\n\n    // Type conversion and validation\n    try {\n      switch (type) {\n        case 'number':\n          return value !== null ? Number(value) : defaultValue;\n        case 'boolean':\n          if (typeof value === 'boolean') {\n            return value;\n          }\n          return value === 'true' || value === '1' || value === 'yes';\n        case 'array':\n          if (Array.isArray(value)) {\n            return value;\n          }\n          return typeof value === 'string' ? value.split(',').map((s) => s.trim()) : defaultValue;\n        case 'string':\n        default:\n          return value !== null ? String(value) : defaultValue;\n      }\n    } catch (error) {\n      console.warn(`Failed to convert environment variable ${key} to ${type}:`, error.message);\n      return defaultValue;\n    }\n  }\n\n  /**\n   * Get research password securely\n   * @deprecated SECURITY: Password verification now handled by backend API only\n   * @returns {string} Research password (deprecated - returns null)\n   */\n  getResearchPassword() {\n    // SECURITY FIX: Password verification moved to backend Cloud Function\n    // No passwords should be stored or checked in frontend code\n    // This function is deprecated and kept only for backward compatibility\n    console.warn('DEPRECATED: getResearchPassword() should not be used. Password verification is backend-only.');\n    return null;\n  }\n\n  /**\n   * Get API key securely\n   * @param {string} service - Service name (e.g., 'OPENROUTE')\n   * @returns {string} API key or null if not configured\n   */\n  getApiKey(service) {\n    const key = this.get(`${service.toUpperCase()}_API_KEY`);\n    if (!key || key === 'YOUR_API_KEY_HERE') {\n      return null;\n    }\n    return key;\n  }\n\n  /**\n   * Check if running in development mode\n   * @returns {boolean} True if in development\n   */\n  isDevelopment() {\n    return this.get('NODE_ENV') === 'development'\n           || typeof window !== 'undefined' && ['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname);\n  }\n\n  /**\n   * Check if running in production mode\n   * @returns {boolean} True if in production\n   */\n  isProduction() {\n    return this.get('NODE_ENV') === 'production' && !this.isDevelopment();\n  }\n\n  /**\n   * Get session configuration\n   * @returns {Object} Session configuration\n   */\n  getSessionConfig() {\n    return {\n      timeoutHours: this.get('SESSION_TIMEOUT_HOURS', 4, 'number'),\n      secretKey: this.get('SESSION_SECRET_KEY') || this.generateSecretKey(),\n      maxAuthAttempts: this.get('MAX_AUTH_ATTEMPTS', 5, 'number'),\n      rateLimitWindow: this.get('RATE_LIMIT_WINDOW_MS', 900000, 'number'),\n    };\n  }\n\n  /**\n   * Get security configuration\n   * @returns {Object} Security configuration\n   */\n  getSecurityConfig() {\n    return {\n      encryptionKeyLength: this.get('ENCRYPTION_KEY_LENGTH', 256, 'number'),\n      bcryptSaltRounds: this.get('BCRYPT_SALT_ROUNDS', 12, 'number'),\n      enableDataEncryption: this.get('ENABLE_DATA_ENCRYPTION', true, 'boolean'),\n      enableAuditTrail: this.get('ENABLE_AUDIT_TRAIL', true, 'boolean'),\n      dataRetentionDays: this.get('DATA_RETENTION_DAYS', 90, 'number'),\n    };\n  }\n\n  /**\n   * Get GCP configuration\n   * @returns {Object} GCP configuration\n   */\n  getGcpConfig() {\n    return {\n      projectId: this.get('GCP_PROJECT_ID', 'igfap-452720'),\n      region: this.get('GCP_REGION', 'europe-west3'),\n      baseUrl: `https://${this.get('GCP_REGION', 'europe-west3')}-${this.get('GCP_PROJECT_ID', 'igfap-452720')}.cloudfunctions.net`,\n    };\n  }\n\n  /**\n   * Generate a secure session secret key\n   * @returns {string} Generated secret key\n   */\n  generateSecretKey() {\n    try {\n      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint8Array(32);\n        crypto.getRandomValues(array);\n        return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');\n      }\n    } catch (error) {\n      console.warn('Failed to generate cryptographically secure key, using fallback');\n    }\n\n    // Fallback for environments without crypto.getRandomValues\n    return `fallback-key-${Date.now()}-${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Validate configuration integrity\n   * @returns {Object} Validation results\n   */\n  validateConfig() {\n    const issues = [];\n    const warnings = [];\n\n    // Check for required security settings\n    if (!this.get('ENABLE_DATA_ENCRYPTION', true, 'boolean')) {\n      issues.push('Data encryption is disabled in production environment');\n    }\n\n    if (!this.get('ENABLE_AUDIT_TRAIL', true, 'boolean')) {\n      warnings.push('Audit trail is disabled - may affect compliance');\n    }\n\n    if (this.get('BCRYPT_SALT_ROUNDS', 12, 'number') < 10) {\n      issues.push('BCrypt salt rounds too low for production security');\n    }\n\n    if (this.isProduction() && this.get('DEBUG_MODE', false, 'boolean')) {\n      warnings.push('Debug mode enabled in production environment');\n    }\n\n    // Check for default/example values in production\n    if (this.isProduction()) {\n      const researchPassword = this.get('RESEARCH_PASSWORD');\n      if (!researchPassword || researchPassword === 'Neuro25') {\n        warnings.push('Using default research password in production');\n      }\n\n      const sessionSecret = this.get('SESSION_SECRET_KEY');\n      if (!sessionSecret || sessionSecret.includes('your-secure')) {\n        issues.push('Default session secret in production environment');\n      }\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      warnings,\n      configStatus: {\n        encryption: this.get('ENABLE_DATA_ENCRYPTION', true, 'boolean'),\n        auditTrail: this.get('ENABLE_AUDIT_TRAIL', true, 'boolean'),\n        development: this.isDevelopment(),\n        production: this.isProduction(),\n      },\n    };\n  }\n\n  /**\n   * Get sanitized configuration for logging/debugging\n   * @returns {Object} Safe configuration object (no secrets)\n   */\n  getSafeConfig() {\n    const safeKeys = [\n      'NODE_ENV', 'DEBUG_MODE', 'MOCK_API_ENABLED', 'LOG_LEVEL',\n      'SESSION_TIMEOUT_HOURS', 'BCRYPT_SALT_ROUNDS', 'ENCRYPTION_KEY_LENGTH',\n      'MAX_AUTH_ATTEMPTS', 'RATE_LIMIT_WINDOW_MS',\n      'ENABLE_DATA_ENCRYPTION', 'ENABLE_AUDIT_TRAIL', 'DATA_RETENTION_DAYS',\n      'GCP_PROJECT_ID', 'GCP_REGION',\n    ];\n\n    const safeConfig = {};\n    safeKeys.forEach((key) => {\n      safeConfig[key] = this.config[key];\n    });\n\n    return safeConfig;\n  }\n}\n\n// Create singleton instance\nconst environmentConfig = new EnvironmentConfig();\n\n// Export convenience functions\nexport const getEnv = (key, defaultValue, type) => environmentConfig.get(key, defaultValue, type);\nexport const getResearchPassword = () => environmentConfig.getResearchPassword();\nexport const getApiKey = (service) => environmentConfig.getApiKey(service);\nexport const isDevelopment = () => environmentConfig.isDevelopment();\nexport const isProduction = () => environmentConfig.isProduction();\nexport const getSessionConfig = () => environmentConfig.getSessionConfig();\nexport const getSecurityConfig = () => environmentConfig.getSecurityConfig();\nexport const getGcpConfig = () => environmentConfig.getGcpConfig();\nexport const validateConfig = () => environmentConfig.validateConfig();\nexport const getSafeConfig = () => environmentConfig.getSafeConfig();\n\n// Export main class\nexport default environmentConfig;\n","/**\n * Comprehensive Error Handling Utilities\n * iGFAP Stroke Triage Assistant - Enterprise Error Management\n *\n * Provides robust error handling for production medical applications\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\n/**\n * Error severity levels\n */\nexport const ERROR_SEVERITY = {\n  LOW: 'low',\n  MEDIUM: 'medium',\n  HIGH: 'high',\n  CRITICAL: 'critical',\n};\n\n/**\n * Error categories for medical applications\n */\nexport const ERROR_CATEGORIES = {\n  NETWORK: 'network',\n  VALIDATION: 'validation',\n  AUTHENTICATION: 'authentication',\n  CALCULATION: 'calculation',\n  STORAGE: 'storage',\n  RENDERING: 'rendering',\n  MEDICAL: 'medical',\n  SECURITY: 'security',\n};\n\n/**\n * Medical error codes\n */\nexport const MEDICAL_ERROR_CODES = {\n  INVALID_VITAL_SIGNS: 'MED001',\n  CALCULATION_FAILED: 'MED002',\n  DATA_INCOMPLETE: 'MED003',\n  PREDICTION_UNAVAILABLE: 'MED004',\n  SAFETY_THRESHOLD_EXCEEDED: 'MED005',\n};\n\n/**\n * Enhanced error class for medical applications\n */\nexport class MedicalError extends Error {\n  constructor(message, code, category = ERROR_CATEGORIES.MEDICAL, severity = ERROR_SEVERITY.MEDIUM) {\n    super(message);\n    this.name = 'MedicalError';\n    this.code = code;\n    this.category = category;\n    this.severity = severity;\n    this.timestamp = new Date().toISOString();\n    this.context = {};\n  }\n\n  /**\n   * Add context to error\n   * @param {Object} context - Error context\n   * @returns {MedicalError} - This error instance\n   */\n  withContext(context) {\n    this.context = { ...this.context, ...context };\n    return this;\n  }\n\n  /**\n   * Get user-friendly error message\n   * @returns {string} - User-friendly message\n   */\n  getUserMessage() {\n    switch (this.category) {\n      case ERROR_CATEGORIES.NETWORK:\n        return 'Network connection issue. Please check your internet connection and try again.';\n      case ERROR_CATEGORIES.VALIDATION:\n        return 'Please check your input data and try again.';\n      case ERROR_CATEGORIES.AUTHENTICATION:\n        return 'Authentication failed. Please log in again.';\n      case ERROR_CATEGORIES.CALCULATION:\n        return 'Unable to complete calculation. Please verify your input data.';\n      case ERROR_CATEGORIES.MEDICAL:\n        return 'Medical calculation could not be completed. Please verify all clinical data.';\n      default:\n        return 'An unexpected error occurred. Please try again.';\n    }\n  }\n}\n\n/**\n * Global error handler for unhandled errors\n */\nclass GlobalErrorHandler {\n  constructor() {\n    this.errorQueue = [];\n    this.maxQueueSize = 100;\n    this.setupGlobalHandlers();\n  }\n\n  setupGlobalHandlers() {\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      this.handleError(event.reason, ERROR_CATEGORIES.NETWORK, ERROR_SEVERITY.HIGH);\n      event.preventDefault();\n    });\n\n    // Handle uncaught errors\n    window.addEventListener('error', (event) => {\n      this.handleError(event.error, ERROR_CATEGORIES.RENDERING, ERROR_SEVERITY.MEDIUM);\n    });\n  }\n\n  handleError(error, category = ERROR_CATEGORIES.NETWORK, severity = ERROR_SEVERITY.MEDIUM) {\n    const errorEntry = {\n      error: error instanceof Error ? error : new Error(String(error)),\n      category,\n      severity,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent.substring(0, 100),\n      url: window.location.href,\n    };\n\n    // Add to queue\n    this.errorQueue.push(errorEntry);\n    if (this.errorQueue.length > this.maxQueueSize) {\n      this.errorQueue.shift();\n    }\n\n    // Handle critical errors immediately\n    if (severity === ERROR_SEVERITY.CRITICAL) {\n      this.handleCriticalError(errorEntry);\n    }\n  }\n\n  handleCriticalError(errorEntry) {\n    // For critical medical errors, show immediate user notification\n    if (errorEntry.category === ERROR_CATEGORIES.MEDICAL) {\n      this.showMedicalAlert(errorEntry.error.message);\n    }\n  }\n\n  showMedicalAlert(message) {\n    // Create a critical medical alert\n    const alert = document.createElement('div');\n    alert.className = 'critical-medical-alert';\n    alert.style.cssText = `\n      position: fixed;\n      top: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: #ff4444;\n      color: white;\n      padding: 15px 20px;\n      border-radius: 8px;\n      z-index: 10000;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n      max-width: 90%;\n      text-align: center;\n    `;\n    alert.textContent = `⚠️ Medical Error: ${message}`;\n\n    document.body.appendChild(alert);\n\n    // Auto-remove after 10 seconds\n    setTimeout(() => {\n      if (document.body.contains(alert)) {\n        document.body.removeChild(alert);\n      }\n    }, 10000);\n  }\n\n  getErrorSummary() {\n    return {\n      totalErrors: this.errorQueue.length,\n      criticalErrors: this.errorQueue.filter((e) => e.severity === ERROR_SEVERITY.CRITICAL).length,\n      recentErrors: this.errorQueue.slice(-10),\n    };\n  }\n}\n\n// Initialize global error handler\nconst globalErrorHandler = new GlobalErrorHandler();\n\n/**\n * Wrapper for async operations with comprehensive error handling\n * @param {Function} asyncFn - Async function to execute\n * @param {Object} options - Error handling options\n * @returns {Promise} - Promise with error handling\n */\nexport async function safeAsync(asyncFn, options = {}) {\n  const {\n    category = ERROR_CATEGORIES.NETWORK,\n    severity = ERROR_SEVERITY.MEDIUM,\n    fallback = null,\n    timeout = 30000,\n    retries = 0,\n    context = {},\n  } = options;\n\n  let lastError;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      // Add timeout wrapper\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Operation timeout')), timeout);\n      });\n\n      const result = await Promise.race([asyncFn(), timeoutPromise]);\n      return result;\n    } catch (error) {\n      lastError = error;\n\n      // Log error\n      globalErrorHandler.handleError(error, category, severity);\n\n      // If we have retries left, wait and retry\n      if (attempt < retries) {\n        await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));\n        continue;\n      }\n\n      // Final attempt failed\n      if (fallback !== null) {\n        return typeof fallback === 'function' ? fallback(error) : fallback;\n      }\n\n      // Throw enhanced error\n      const enhancedError = new MedicalError(\n        error.message || 'Operation failed',\n        error.code || 'UNKNOWN',\n        category,\n        severity,\n      ).withContext(context);\n\n      throw enhancedError;\n    }\n  }\n}\n\n/**\n * Safe wrapper for medical calculations\n * @param {Function} calculationFn - Medical calculation function\n * @param {Object} inputs - Input data\n * @param {Object} options - Calculation options\n * @returns {Promise} - Calculation result with error handling\n */\nexport async function safeMedicalCalculation(calculationFn, inputs, options = {}) {\n  return safeAsync(\n    () => calculationFn(inputs),\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.HIGH,\n      fallback: () => ({\n        error: true,\n        message: 'Medical calculation unavailable',\n        fallbackUsed: true,\n      }),\n      context: {\n        operation: 'medical_calculation',\n        inputKeys: Object.keys(inputs || {}),\n        ...options.context,\n      },\n      ...options,\n    },\n  );\n}\n\n/**\n * Safe wrapper for network requests\n * @param {Function} requestFn - Network request function\n * @param {Object} options - Request options\n * @returns {Promise} - Request result with error handling\n */\nexport async function safeNetworkRequest(requestFn, options = {}) {\n  return safeAsync(requestFn, {\n    category: ERROR_CATEGORIES.NETWORK,\n    severity: ERROR_SEVERITY.MEDIUM,\n    retries: 2,\n    timeout: 10000,\n    fallback: () => ({\n      error: true,\n      message: 'Network request failed',\n      offline: true,\n    }),\n    ...options,\n  });\n}\n\n/**\n * Safe wrapper for authentication operations\n * @param {Function} authFn - Authentication function\n * @param {Object} options - Auth options\n * @returns {Promise} - Auth result with error handling\n */\nexport async function safeAuthOperation(authFn, options = {}) {\n  return safeAsync(authFn, {\n    category: ERROR_CATEGORIES.AUTHENTICATION,\n    severity: ERROR_SEVERITY.HIGH,\n    timeout: 15000,\n    fallback: () => ({\n      success: false,\n      error: true,\n      message: 'Authentication service unavailable',\n    }),\n    ...options,\n  });\n}\n\n/**\n * Create error boundary for React-like error handling\n * @param {HTMLElement} element - DOM element to wrap\n * @param {Function} renderFn - Function to render content\n * @param {Function} errorFn - Function to render error state\n */\nexport function createErrorBoundary(element, renderFn, errorFn) {\n  try {\n    renderFn();\n  } catch (error) {\n    globalErrorHandler.handleError(error, ERROR_CATEGORIES.RENDERING, ERROR_SEVERITY.MEDIUM);\n\n    if (errorFn) {\n      errorFn(error);\n    } else {\n      element.textContent = 'Content could not be displayed due to an error.';\n    }\n  }\n}\n\n/**\n * Validate medical input data\n * @param {Object} data - Input data\n * @param {Object} schema - Validation schema\n * @returns {Object} - Validation result\n */\nexport function validateMedicalInputs(data, schema) {\n  const errors = [];\n  const warnings = [];\n\n  Object.keys(schema).forEach((key) => {\n    const rule = schema[key];\n    const value = data[key];\n\n    // Required field check\n    if (rule.required && (value === undefined || value === null || value === '')) {\n      errors.push({\n        field: key,\n        code: MEDICAL_ERROR_CODES.DATA_INCOMPLETE,\n        message: `${key} is required`,\n      });\n      return;\n    }\n\n    // Type check\n    if (value !== undefined && rule.type) {\n      const expectedType = rule.type;\n      const actualType = typeof value;\n\n      if (expectedType === 'number' && (isNaN(value) || actualType !== 'number')) {\n        errors.push({\n          field: key,\n          code: MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          message: `${key} must be a valid number`,\n        });\n        return;\n      }\n    }\n\n    // Range check for medical values\n    if (value !== undefined && typeof value === 'number') {\n      if (rule.min !== undefined && value < rule.min) {\n        errors.push({\n          field: key,\n          code: MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          message: `${key} must be at least ${rule.min}`,\n        });\n      }\n\n      if (rule.max !== undefined && value > rule.max) {\n        errors.push({\n          field: key,\n          code: MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          message: `${key} must not exceed ${rule.max}`,\n        });\n      }\n\n      // Medical warning thresholds\n      if (rule.warningMin !== undefined && value < rule.warningMin) {\n        warnings.push({\n          field: key,\n          message: `${key} is below typical range (${rule.warningMin})`,\n        });\n      }\n\n      if (rule.warningMax !== undefined && value > rule.warningMax) {\n        warnings.push({\n          field: key,\n          message: `${key} is above typical range (${rule.warningMax})`,\n        });\n      }\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    hasWarnings: warnings.length > 0,\n  };\n}\n\n/**\n * Get error handler instance for debugging\n */\nexport function getErrorHandler() {\n  return globalErrorHandler;\n}\n\n/**\n * Export error classes\n */\nexport { GlobalErrorHandler };\n","/**\n * Professional Medical Logging System\n * iGFAP Stroke Triage Assistant - Enterprise-Grade Logging\n *\n * Provides structured, secure logging for medical applications with:\n * - HIPAA compliance (no PHI in logs)\n * - Structured JSON logging\n * - Performance monitoring\n * - Error tracking\n * - Audit trail capabilities\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\nimport { safeAsync, ERROR_CATEGORIES } from './error-handler.js';\n\n/**\n * @typedef {Object} LogEntry\n * @property {string} timestamp - ISO timestamp\n * @property {string} level - Log level\n * @property {string} category - Log category\n * @property {string} message - Log message\n * @property {Object} [context] - Additional context (sanitized)\n * @property {string} [sessionId] - Session identifier\n * @property {string} [userId] - User identifier (anonymized)\n * @property {Object} [performance] - Performance metrics\n * @property {string} [stackTrace] - Stack trace for errors\n */\n\n/**\n * Log levels with priority ordering\n */\nexport const LOG_LEVELS = {\n  DEBUG: { level: 0, name: 'DEBUG', color: '#6366f1' },\n  INFO: { level: 1, name: 'INFO', color: '#10b981' },\n  WARN: { level: 2, name: 'WARN', color: '#f59e0b' },\n  ERROR: { level: 3, name: 'ERROR', color: '#ef4444' },\n  CRITICAL: { level: 4, name: 'CRITICAL', color: '#dc2626' },\n};\n\n/**\n * Log categories for medical application\n */\nexport const LOG_CATEGORIES = {\n  AUTHENTICATION: 'AUTH',\n  MEDICAL_CALCULATION: 'MEDICAL',\n  NETWORK: 'NETWORK',\n  PERFORMANCE: 'PERF',\n  SECURITY: 'SECURITY',\n  USER_INTERACTION: 'UI',\n  DATA_VALIDATION: 'VALIDATION',\n  AUDIT: 'AUDIT',\n  SYSTEM: 'SYSTEM',\n  ERROR: 'ERROR',\n};\n\n/**\n * Professional Medical Logger Class\n */\nexport class MedicalLogger {\n  constructor() {\n    this.logLevel = this.getLogLevel();\n    this.sessionId = this.generateSessionId();\n    this.logBuffer = [];\n    this.maxBufferSize = 1000;\n    this.isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';\n    this.enableConsole = !this.isProduction;\n    this.enableStorage = true;\n    this.enableNetwork = false; // Would send to logging service in production\n\n    this.setupErrorHandlers();\n    this.startPeriodicFlush();\n  }\n\n  /**\n   * Get configured log level from environment or localStorage\n   */\n  getLogLevel() {\n    try {\n      const stored = localStorage.getItem('medicalLogLevel');\n      if (stored && LOG_LEVELS[stored.toUpperCase()]) {\n        return LOG_LEVELS[stored.toUpperCase()].level;\n      }\n    } catch (error) {\n      // localStorage not available\n    }\n\n    // Default to INFO in production, DEBUG in development\n    return this.isProduction ? LOG_LEVELS.INFO.level : LOG_LEVELS.DEBUG.level;\n  }\n\n  /**\n   * Generate unique session identifier\n   */\n  generateSessionId() {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 8);\n    return `sess_${timestamp}_${random}`;\n  }\n\n  /**\n   * Setup global error handlers\n   */\n  setupErrorHandlers() {\n    // Capture unhandled errors\n    window.addEventListener('error', (event) => {\n      try {\n        this.critical('Unhandled JavaScript Error', {\n          category: LOG_CATEGORIES.ERROR,\n          message: event.message,\n          filename: event.filename,\n          lineno: event.lineno,\n          colno: event.colno,\n          stack: event.error?.stack,\n        });\n      } catch (loggingError) {\n        // Fallback to console if logging fails\n        console.error('Logging failed:', loggingError);\n        console.error('Original error:', event.error);\n      }\n    });\n\n    // Capture unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      try {\n        this.critical('Unhandled Promise Rejection', {\n          category: LOG_CATEGORIES.ERROR,\n          reason: event.reason?.message || String(event.reason) || 'Unknown rejection',\n          stack: event.reason?.stack,\n        });\n      } catch (loggingError) {\n        // Fallback to console if logging fails\n        console.error('Logging failed:', loggingError);\n        console.error('Original rejection:', event.reason);\n      }\n    });\n  }\n\n  /**\n   * Create structured log entry\n   */\n  createLogEntry(level, message, context = {}) {\n    // Ensure context is always an object\n    const safeContext = context && typeof context === 'object' ? context : {};\n\n    const entry = {\n      timestamp: new Date().toISOString(),\n      level: LOG_LEVELS[level]?.name || level,\n      category: safeContext.category || LOG_CATEGORIES.SYSTEM,\n      message: this.sanitizeMessage(message),\n      sessionId: this.sessionId,\n      context: this.sanitizeContext(safeContext),\n      performance: this.getPerformanceMetrics(),\n    };\n\n    // Add stack trace for errors\n    if (level === 'ERROR' || level === 'CRITICAL') {\n      entry.stackTrace = new Error().stack;\n    }\n\n    // Add user ID if available (anonymized)\n    const userId = this.getAnonymizedUserId();\n    if (userId) {\n      entry.userId = userId;\n    }\n\n    return entry;\n  }\n\n  /**\n   * Sanitize message to remove PHI\n   */\n  sanitizeMessage(message) {\n    if (typeof message !== 'string') {\n      message = String(message);\n    }\n\n    // Remove potential PHI patterns\n    const sanitized = message\n      .replace(/\\b\\d{3}-\\d{2}-\\d{4}\\b/g, '***-**-****') // SSN\n      .replace(/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g, '***@***.***') // Email\n      .replace(/\\b\\d{10,}\\b/g, '**********') // Phone numbers\n      .replace(/\\b[A-Z][a-z]+ [A-Z][a-z]+\\b/g, '[NAME]'); // Names\n\n    return sanitized;\n  }\n\n  /**\n   * Sanitize context object to remove PHI\n   */\n  sanitizeContext(context) {\n    // Handle null or non-object inputs\n    if (!context || typeof context !== 'object') {\n      return {};\n    }\n\n    const sanitized = { ...context };\n\n    // Remove sensitive fields\n    const sensitiveFields = [\n      'password', 'token', 'sessionToken', 'authToken',\n      'patientName', 'firstName', 'lastName', 'fullName',\n      'email', 'phone', 'ssn', 'mrn', 'dob', 'dateOfBirth',\n    ];\n\n    const removeSensitiveData = (obj) => {\n      if (!obj || typeof obj !== 'object') {\n        return obj;\n      }\n\n      const cleaned = Array.isArray(obj) ? [] : {};\n\n      for (const [key, value] of Object.entries(obj)) {\n        const lowerKey = key.toLowerCase();\n\n        if (sensitiveFields.some((field) => lowerKey.includes(field))) {\n          cleaned[key] = '[REDACTED]';\n        } else if (typeof value === 'object' && value !== null) {\n          cleaned[key] = removeSensitiveData(value);\n        } else {\n          cleaned[key] = value;\n        }\n      }\n\n      return cleaned;\n    };\n\n    return removeSensitiveData(sanitized);\n  }\n\n  /**\n   * Get anonymized user ID\n   */\n  getAnonymizedUserId() {\n    try {\n      // Use a hash of session info, not actual user data\n      const sessionData = sessionStorage.getItem('session_hash');\n      if (sessionData) {\n        return `user_${sessionData.substring(0, 8)}`;\n      }\n    } catch (error) {\n      // Session storage not available\n    }\n    return null;\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getPerformanceMetrics() {\n    try {\n      if ('performance' in window) {\n        const navigation = performance.getEntriesByType('navigation')[0];\n        return {\n          memoryUsed: performance.memory?.usedJSHeapSize || 0,\n          loadTime: navigation?.loadEventEnd - navigation?.loadEventStart || 0,\n          domReady: navigation?.domContentLoadedEventEnd - navigation?.domContentLoadedEventStart || 0,\n        };\n      }\n    } catch (error) {\n      // Performance API not available\n    }\n    return null;\n  }\n\n  /**\n   * Log message at specified level\n   */\n  log(level, message, context = {}) {\n    return safeAsync(\n      async () => {\n        // Validate inputs\n        if (!level || !message) {\n          return; // Skip logging if no level or message\n        }\n\n        const levelInfo = LOG_LEVELS[level.toUpperCase()];\n        if (!levelInfo || levelInfo.level < this.logLevel) {\n          return; // Below configured log level\n        }\n\n        const entry = this.createLogEntry(level.toUpperCase(), message, context);\n\n        // Add to buffer\n        this.addToBuffer(entry);\n\n        // Console output in development\n        if (this.enableConsole) {\n          this.outputToConsole(entry);\n        }\n\n        // Store locally\n        if (this.enableStorage) {\n          this.storeEntry(entry);\n        }\n\n        // Send to logging service (production)\n        if (this.enableNetwork) {\n          await this.sendToLoggingService(entry);\n        }\n      },\n      {\n        category: ERROR_CATEGORIES.SYSTEM,\n        context: { operation: 'logging', level, message: message.substring(0, 100) },\n      },\n    );\n  }\n\n  /**\n   * Add entry to buffer\n   */\n  addToBuffer(entry) {\n    this.logBuffer.push(entry);\n\n    // Maintain buffer size\n    if (this.logBuffer.length > this.maxBufferSize) {\n      this.logBuffer = this.logBuffer.slice(-this.maxBufferSize);\n    }\n  }\n\n  /**\n   * Output to browser console with styling\n   */\n  outputToConsole(entry) {\n    const levelInfo = LOG_LEVELS[entry.level];\n    const color = levelInfo?.color || '#666666';\n\n    const style = `color: ${color}; font-weight: bold;`;\n    const timestamp = new Date(entry.timestamp).toLocaleTimeString();\n\n    const consoleMethod = entry.level === 'ERROR' || entry.level === 'CRITICAL' ? 'error'\n      : entry.level === 'WARN' ? 'warn' : 'log';\n\n    console.groupCollapsed(\n      `%c[${entry.level}] ${timestamp} [${entry.category}] ${entry.message}`,\n      style,\n    );\n\n    if (entry.context && Object.keys(entry.context).length > 0) {\n      console.log('Context:', entry.context);\n    }\n\n    if (entry.performance) {\n      console.log('Performance:', entry.performance);\n    }\n\n    if (entry.stackTrace && (entry.level === 'ERROR' || entry.level === 'CRITICAL')) {\n      console.log('Stack Trace:', entry.stackTrace);\n    }\n\n    console.groupEnd();\n  }\n\n  /**\n   * Store entry locally\n   */\n  storeEntry(entry) {\n    try {\n      const key = `medicalLog_${entry.timestamp}`;\n      const serialized = JSON.stringify(entry);\n\n      // Use sessionStorage for temporary storage\n      sessionStorage.setItem(key, serialized);\n\n      // Clean old entries (keep last 100)\n      this.cleanOldEntries();\n    } catch (error) {\n      // Storage failed - continue silently\n    }\n  }\n\n  /**\n   * Clean old log entries from storage\n   */\n  cleanOldEntries() {\n    try {\n      const keys = Object.keys(sessionStorage)\n        .filter((key) => key.startsWith('medicalLog_'))\n        .sort()\n        .reverse();\n\n      // Keep only the last 100 entries\n      if (keys.length > 100) {\n        keys.slice(100).forEach((key) => {\n          sessionStorage.removeItem(key);\n        });\n      }\n    } catch (error) {\n      // Cleanup failed - continue silently\n    }\n  }\n\n  /**\n   * Send to remote logging service\n   */\n  async sendToLoggingService(entry) {\n    // In production, this would send to a logging service like:\n    // - Google Cloud Logging\n    // - AWS CloudWatch\n    // - Elastic Stack\n    // - Splunk\n\n    // For now, just return - would implement actual service call\n    return Promise.resolve();\n  }\n\n  /**\n   * Start periodic buffer flush\n   */\n  startPeriodicFlush() {\n    setInterval(() => {\n      this.flushBuffer();\n    }, 30000); // Flush every 30 seconds\n  }\n\n  /**\n   * Flush log buffer\n   */\n  flushBuffer() {\n    if (this.logBuffer.length === 0) {\n      return;\n    }\n\n    // In production, this would batch-send logs to service\n    this.info('Log buffer flushed', {\n      category: LOG_CATEGORIES.SYSTEM,\n      entriesCount: this.logBuffer.length,\n    });\n  }\n\n  /**\n   * Convenience methods for different log levels\n   */\n  debug(message, context = {}) {\n    return this.log('DEBUG', message, context);\n  }\n\n  info(message, context = {}) {\n    return this.log('INFO', message, context);\n  }\n\n  warn(message, context = {}) {\n    return this.log('WARN', message, context);\n  }\n\n  error(message, context = {}) {\n    return this.log('ERROR', message, context);\n  }\n\n  critical(message, context = {}) {\n    return this.log('CRITICAL', message, context);\n  }\n\n  /**\n   * Specialized medical logging methods\n   */\n  medicalCalculation(operation, result, context = {}) {\n    return this.info(`Medical calculation: ${operation}`, {\n      category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n      operation,\n      success: !context.error,\n      ...context,\n    });\n  }\n\n  authentication(action, success, context = {}) {\n    return this.info(`Authentication: ${action}`, {\n      category: LOG_CATEGORIES.AUTHENTICATION,\n      action,\n      success,\n      ...context,\n    });\n  }\n\n  userInteraction(action, context = {}) {\n    return this.debug(`User interaction: ${action}`, {\n      category: LOG_CATEGORIES.USER_INTERACTION,\n      action,\n      ...context,\n    });\n  }\n\n  networkRequest(url, method, status, context = {}) {\n    const level = status >= 400 ? 'ERROR' : status >= 300 ? 'WARN' : 'DEBUG';\n    return this.log(level, `Network request: ${method} ${url}`, {\n      category: LOG_CATEGORIES.NETWORK,\n      method,\n      url: this.sanitizeUrl(url),\n      status,\n      ...context,\n    });\n  }\n\n  performance(metric, value, context = {}) {\n    return this.debug(`Performance metric: ${metric} = ${value}`, {\n      category: LOG_CATEGORIES.PERFORMANCE,\n      metric,\n      value,\n      ...context,\n    });\n  }\n\n  auditTrail(event, context = {}) {\n    return this.info(`Audit: ${event}`, {\n      category: LOG_CATEGORIES.AUDIT,\n      event,\n      ...context,\n    });\n  }\n\n  /**\n   * Sanitize URL to remove sensitive parameters\n   */\n  sanitizeUrl(url) {\n    try {\n      const urlObj = new URL(url);\n      const sensitiveParams = ['token', 'auth', 'key', 'secret'];\n\n      sensitiveParams.forEach((param) => {\n        if (urlObj.searchParams.has(param)) {\n          urlObj.searchParams.set(param, '[REDACTED]');\n        }\n      });\n\n      return urlObj.toString();\n    } catch (error) {\n      return url;\n    }\n  }\n\n  /**\n   * Get all logs from buffer and storage\n   */\n  getLogs(filters = {}) {\n    const allLogs = [...this.logBuffer];\n\n    // Add logs from storage\n    try {\n      const keys = Object.keys(sessionStorage)\n        .filter((key) => key.startsWith('medicalLog_'))\n        .sort();\n\n      keys.forEach((key) => {\n        try {\n          const entry = JSON.parse(sessionStorage.getItem(key));\n          if (entry && !allLogs.find((log) => log.timestamp === entry.timestamp)) {\n            allLogs.push(entry);\n          }\n        } catch (error) {\n          // Skip corrupted entries\n        }\n      });\n    } catch (error) {\n      // Storage access failed\n    }\n\n    // Apply filters\n    let filtered = allLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n\n    if (filters.level) {\n      const minLevel = LOG_LEVELS[filters.level.toUpperCase()]?.level || 0;\n      filtered = filtered.filter((log) => {\n        const logLevel = LOG_LEVELS[log.level]?.level || 0;\n        return logLevel >= minLevel;\n      });\n    }\n\n    if (filters.category) {\n      filtered = filtered.filter((log) => log.category === filters.category);\n    }\n\n    if (filters.since) {\n      const sinceDate = new Date(filters.since);\n      filtered = filtered.filter((log) => new Date(log.timestamp) >= sinceDate);\n    }\n\n    if (filters.limit) {\n      filtered = filtered.slice(0, filters.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Export logs for debugging or compliance\n   */\n  exportLogs(format = 'json') {\n    const logs = this.getLogs();\n\n    if (format === 'csv') {\n      return this.logsToCSV(logs);\n    }\n\n    return JSON.stringify(logs, null, 2);\n  }\n\n  /**\n   * Convert logs to CSV format\n   */\n  logsToCSV(logs) {\n    if (logs.length === 0) {\n      return '';\n    }\n\n    const headers = ['timestamp', 'level', 'category', 'message', 'sessionId'];\n    const rows = logs.map((log) => [\n      log.timestamp,\n      log.level,\n      log.category,\n      `\"${log.message.replace(/\"/g, '\"\"')}\"`,\n      log.sessionId,\n    ]);\n\n    return [headers.join(','), ...rows.map((row) => row.join(','))].join('\\n');\n  }\n\n  /**\n   * Clear all logs\n   */\n  clearLogs() {\n    this.logBuffer = [];\n\n    try {\n      const keys = Object.keys(sessionStorage)\n        .filter((key) => key.startsWith('medicalLog_'));\n\n      keys.forEach((key) => sessionStorage.removeItem(key));\n    } catch (error) {\n      // Storage cleanup failed\n    }\n\n    this.info('Log storage cleared', {\n      category: LOG_CATEGORIES.SYSTEM,\n    });\n  }\n}\n\n// Create global logger instance\nexport const medicalLogger = new MedicalLogger();\n\n// Export convenience functions\nexport const {\n  debug,\n  info,\n  warn,\n  error,\n  critical,\n  medicalCalculation,\n  authentication,\n  userInteraction,\n  networkRequest,\n  performance,\n  auditTrail,\n} = medicalLogger;\n","/**\n * Medical Data Encryption System\n * iGFAP Stroke Triage Assistant - HIPAA-Compliant Data Protection\n *\n * Provides client-side encryption for sensitive medical data in storage\n * Uses Web Crypto API with AES-GCM encryption for maximum security\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\nimport { safeAsync, ERROR_CATEGORIES, ERROR_SEVERITY } from '../utils/error-handler.js';\nimport { medicalLogger, LOG_CATEGORIES } from '../utils/medical-logger.js';\n\n/**\n * @typedef {Object} EncryptedData\n * @property {string} encrypted - Base64 encoded encrypted data\n * @property {string} iv - Base64 encoded initialization vector\n * @property {string} version - Encryption version for compatibility\n * @property {number} timestamp - Encryption timestamp\n */\n\n/**\n * Medical Data Encryption Manager\n */\nexport class MedicalDataEncryption {\n  constructor() {\n    this.algorithm = 'AES-GCM';\n    this.keyLength = 256;\n    this.ivLength = 12; // 96 bits for AES-GCM\n    this.version = '1.0';\n    this.encryptionKey = null;\n    this.isSupported = this.checkWebCryptoSupport();\n\n    if (this.isSupported) {\n      this.initializeEncryption();\n    } else {\n      medicalLogger.warn('Web Crypto API not supported, falling back to unencrypted storage', {\n        category: LOG_CATEGORIES.SECURITY,\n      });\n    }\n  }\n\n  /**\n   * Check if Web Crypto API is supported\n   */\n  checkWebCryptoSupport() {\n    return typeof window !== 'undefined'\n           && window.crypto\n           && window.crypto.subtle\n           && typeof window.crypto.subtle.encrypt === 'function';\n  }\n\n  /**\n   * Initialize encryption with derived key\n   */\n  async initializeEncryption() {\n    return safeAsync(\n      async () => {\n        // Generate or retrieve session-based key material\n        const keyMaterial = await this.getOrCreateKeyMaterial();\n\n        // Derive encryption key from key material\n        this.encryptionKey = await window.crypto.subtle.deriveKey(\n          {\n            name: 'PBKDF2',\n            salt: new TextEncoder().encode('iGFAP-Medical-2024'), // Static salt for session consistency\n            iterations: 100000,\n            hash: 'SHA-256',\n          },\n          keyMaterial,\n          {\n            name: this.algorithm,\n            length: this.keyLength,\n          },\n          false, // Not extractable for security\n          ['encrypt', 'decrypt'],\n        );\n\n        medicalLogger.info('Medical data encryption initialized', {\n          category: LOG_CATEGORIES.SECURITY,\n          algorithm: this.algorithm,\n          keyLength: this.keyLength,\n        });\n\n        return true;\n      },\n      {\n        category: ERROR_CATEGORIES.SECURITY,\n        severity: ERROR_SEVERITY.HIGH,\n        context: { operation: 'encryption_initialization' },\n      },\n    );\n  }\n\n  /**\n   * Get or create key material for encryption\n   */\n  async getOrCreateKeyMaterial() {\n    return safeAsync(\n      async () => {\n        // Try to get existing key material from session\n        let keyData = sessionStorage.getItem('_medical_km');\n\n        if (!keyData) {\n          // Generate new key material for this session\n          const randomBytes = window.crypto.getRandomValues(new Uint8Array(32));\n          keyData = Array.from(randomBytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n          sessionStorage.setItem('_medical_km', keyData);\n\n          medicalLogger.debug('Generated new encryption key material', {\n            category: LOG_CATEGORIES.SECURITY,\n          });\n        }\n\n        // Convert hex string back to Uint8Array\n        const keyBytes = new Uint8Array(keyData.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));\n\n        // Import key material\n        return await window.crypto.subtle.importKey(\n          'raw',\n          keyBytes,\n          'PBKDF2',\n          false,\n          ['deriveKey'],\n        );\n      },\n      {\n        category: ERROR_CATEGORIES.SECURITY,\n        context: { operation: 'key_material_generation' },\n      },\n    );\n  }\n\n  /**\n   * Encrypt sensitive data\n   * @param {any} data - Data to encrypt\n   * @returns {Promise<EncryptedData|string>} Encrypted data object or original data if encryption fails\n   */\n  async encryptData(data) {\n    if (!this.isSupported || !this.encryptionKey) {\n      medicalLogger.warn('Encryption not available, storing data unencrypted', {\n        category: LOG_CATEGORIES.SECURITY,\n      });\n      return JSON.stringify(data);\n    }\n\n    return safeAsync(\n      async () => {\n        // Convert data to JSON string\n        const jsonString = JSON.stringify(data);\n        const dataBytes = new TextEncoder().encode(jsonString);\n\n        // Generate random IV\n        const iv = window.crypto.getRandomValues(new Uint8Array(this.ivLength));\n\n        // Encrypt the data\n        const encryptedBuffer = await window.crypto.subtle.encrypt(\n          {\n            name: this.algorithm,\n            iv,\n          },\n          this.encryptionKey,\n          dataBytes,\n        );\n\n        // Convert to base64 for storage\n        const encryptedArray = new Uint8Array(encryptedBuffer);\n        const encryptedBase64 = btoa(String.fromCharCode(...encryptedArray));\n        const ivBase64 = btoa(String.fromCharCode(...iv));\n\n        const encryptedData = {\n          encrypted: encryptedBase64,\n          iv: ivBase64,\n          version: this.version,\n          timestamp: Date.now(),\n        };\n\n        medicalLogger.debug('Data encrypted successfully', {\n          category: LOG_CATEGORIES.SECURITY,\n          dataSize: jsonString.length,\n        });\n\n        return JSON.stringify(encryptedData);\n      },\n      {\n        category: ERROR_CATEGORIES.SECURITY,\n        severity: ERROR_SEVERITY.MEDIUM,\n        fallback: () => {\n          medicalLogger.warn('Encryption failed, storing data unencrypted', {\n            category: LOG_CATEGORIES.SECURITY,\n          });\n          return JSON.stringify(data);\n        },\n        context: { operation: 'data_encryption' },\n      },\n    );\n  }\n\n  /**\n   * Decrypt sensitive data\n   * @param {string} encryptedDataString - Encrypted data string\n   * @returns {Promise<any>} Decrypted data or null if decryption fails\n   */\n  async decryptData(encryptedDataString) {\n    if (!encryptedDataString) {\n      return null;\n    }\n\n    return safeAsync(\n      async () => {\n        let encryptedData;\n        try {\n          encryptedData = JSON.parse(encryptedDataString);\n        } catch (parseError) {\n          // Might be unencrypted legacy data\n          medicalLogger.debug('Data appears to be unencrypted legacy format', {\n            category: LOG_CATEGORIES.SECURITY,\n          });\n          return JSON.parse(encryptedDataString);\n        }\n\n        // Check if this is encrypted data\n        if (!encryptedData.encrypted || !encryptedData.iv) {\n          // Assume it's unencrypted data\n          return encryptedData;\n        }\n\n        if (!this.isSupported || !this.encryptionKey) {\n          medicalLogger.warn('Cannot decrypt data: encryption not available', {\n            category: LOG_CATEGORIES.SECURITY,\n          });\n          return null;\n        }\n\n        // Convert base64 back to Uint8Array\n        const encryptedBytes = new Uint8Array(\n          atob(encryptedData.encrypted)\n            .split('')\n            .map((char) => char.charCodeAt(0)),\n        );\n\n        const iv = new Uint8Array(\n          atob(encryptedData.iv)\n            .split('')\n            .map((char) => char.charCodeAt(0)),\n        );\n\n        // Decrypt the data\n        const decryptedBuffer = await window.crypto.subtle.decrypt(\n          {\n            name: this.algorithm,\n            iv,\n          },\n          this.encryptionKey,\n          encryptedBytes,\n        );\n\n        // Convert back to string and parse JSON\n        const decryptedString = new TextDecoder().decode(decryptedBuffer);\n        const decryptedData = JSON.parse(decryptedString);\n\n        medicalLogger.debug('Data decrypted successfully', {\n          category: LOG_CATEGORIES.SECURITY,\n          dataSize: decryptedString.length,\n        });\n\n        return decryptedData;\n      },\n      {\n        category: ERROR_CATEGORIES.SECURITY,\n        severity: ERROR_SEVERITY.MEDIUM,\n        fallback: () => {\n          medicalLogger.warn('Decryption failed, returning null', {\n            category: LOG_CATEGORIES.SECURITY,\n          });\n          return null;\n        },\n        context: { operation: 'data_decryption' },\n      },\n    );\n  }\n\n  /**\n   * Securely store encrypted data\n   * @param {string} key - Storage key\n   * @param {any} data - Data to store\n   * @param {boolean} useSessionStorage - Use sessionStorage instead of localStorage\n   */\n  async secureStore(key, data, useSessionStorage = false) {\n    return safeAsync(\n      async () => {\n        const storage = useSessionStorage ? sessionStorage : localStorage;\n\n        // Encrypt the data\n        const encryptedData = await this.encryptData(data);\n\n        // Store with encrypted prefix to identify encrypted data\n        const storageKey = `_enc_${key}`;\n        storage.setItem(storageKey, encryptedData);\n\n        medicalLogger.debug('Data stored securely', {\n          category: LOG_CATEGORIES.SECURITY,\n          key: storageKey,\n          storage: useSessionStorage ? 'session' : 'local',\n        });\n\n        return true;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        context: { operation: 'secure_store', key },\n      },\n    );\n  }\n\n  /**\n   * Securely retrieve and decrypt data\n   * @param {string} key - Storage key\n   * @param {boolean} useSessionStorage - Use sessionStorage instead of localStorage\n   * @returns {Promise<any>} Decrypted data or null\n   */\n  async secureRetrieve(key, useSessionStorage = false) {\n    return safeAsync(\n      async () => {\n        const storage = useSessionStorage ? sessionStorage : localStorage;\n        const storageKey = `_enc_${key}`;\n\n        const encryptedData = storage.getItem(storageKey);\n        if (!encryptedData) {\n          // Try legacy unencrypted key\n          const legacyData = storage.getItem(key);\n          if (legacyData) {\n            medicalLogger.debug('Retrieved legacy unencrypted data', {\n              category: LOG_CATEGORIES.SECURITY,\n              key,\n            });\n            try {\n              return JSON.parse(legacyData);\n            } catch (error) {\n              return legacyData;\n            }\n          }\n          return null;\n        }\n\n        // Decrypt the data\n        const decryptedData = await this.decryptData(encryptedData);\n\n        medicalLogger.debug('Data retrieved securely', {\n          category: LOG_CATEGORIES.SECURITY,\n          key: storageKey,\n          storage: useSessionStorage ? 'session' : 'local',\n          hasData: !!decryptedData,\n        });\n\n        return decryptedData;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        context: { operation: 'secure_retrieve', key },\n      },\n    );\n  }\n\n  /**\n   * Securely remove data\n   * @param {string} key - Storage key\n   * @param {boolean} useSessionStorage - Use sessionStorage instead of localStorage\n   */\n  async secureRemove(key, useSessionStorage = false) {\n    return safeAsync(\n      async () => {\n        const storage = useSessionStorage ? sessionStorage : localStorage;\n        const storageKey = `_enc_${key}`;\n\n        // Remove both encrypted and legacy versions\n        storage.removeItem(storageKey);\n        storage.removeItem(key);\n\n        medicalLogger.debug('Data removed securely', {\n          category: LOG_CATEGORIES.SECURITY,\n          key: storageKey,\n          storage: useSessionStorage ? 'session' : 'local',\n        });\n\n        return true;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        context: { operation: 'secure_remove', key },\n      },\n    );\n  }\n\n  /**\n   * Check if data is encrypted\n   * @param {string} dataString - Data string to check\n   * @returns {boolean} True if data appears to be encrypted\n   */\n  isDataEncrypted(dataString) {\n    try {\n      const parsed = JSON.parse(dataString);\n      return !!(parsed.encrypted && parsed.iv && parsed.version);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Migrate legacy unencrypted data to encrypted format\n   * @param {string} key - Storage key\n   * @param {boolean} useSessionStorage - Use sessionStorage instead of localStorage\n   */\n  async migrateLegacyData(key, useSessionStorage = false) {\n    return safeAsync(\n      async () => {\n        const storage = useSessionStorage ? sessionStorage : localStorage;\n        const legacyData = storage.getItem(key);\n\n        if (legacyData && !this.isDataEncrypted(legacyData)) {\n          medicalLogger.info('Migrating legacy unencrypted data', {\n            category: LOG_CATEGORIES.SECURITY,\n            key,\n          });\n\n          // Parse legacy data\n          let parsedData;\n          try {\n            parsedData = JSON.parse(legacyData);\n          } catch (error) {\n            parsedData = legacyData;\n          }\n\n          // Store encrypted version\n          await this.secureStore(key.replace('_enc_', ''), parsedData, useSessionStorage);\n\n          // Remove legacy version\n          storage.removeItem(key);\n\n          medicalLogger.info('Legacy data migration completed', {\n            category: LOG_CATEGORIES.SECURITY,\n            key,\n          });\n\n          return true;\n        }\n\n        return false;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        context: { operation: 'migrate_legacy_data', key },\n      },\n    );\n  }\n\n  /**\n   * Clear all encryption keys (for logout)\n   */\n  clearEncryptionKeys() {\n    try {\n      sessionStorage.removeItem('_medical_km');\n      this.encryptionKey = null;\n\n      medicalLogger.info('Encryption keys cleared', {\n        category: LOG_CATEGORIES.SECURITY,\n      });\n    } catch (error) {\n      medicalLogger.warn('Failed to clear encryption keys', {\n        category: LOG_CATEGORIES.SECURITY,\n        error: error.message,\n      });\n    }\n  }\n\n  /**\n   * Get encryption status\n   */\n  getStatus() {\n    return {\n      isSupported: this.isSupported,\n      isInitialized: !!this.encryptionKey,\n      algorithm: this.algorithm,\n      keyLength: this.keyLength,\n      version: this.version,\n    };\n  }\n}\n\n// Create global instance\nexport const medicalEncryption = new MedicalDataEncryption();\n\n// Convenience functions\nexport const secureStore = (key, data, useSessionStorage = false) => medicalEncryption.secureStore(key, data, useSessionStorage);\n\nexport const secureRetrieve = (key, useSessionStorage = false) => medicalEncryption.secureRetrieve(key, useSessionStorage);\n\nexport const secureRemove = (key, useSessionStorage = false) => medicalEncryption.secureRemove(key, useSessionStorage);\n\nexport const clearEncryptionKeys = () => medicalEncryption.clearEncryptionKeys();\n","/**\n * Service Worker Manager for Medical Application\n * iGFAP Stroke Triage Assistant - Phase 3 Advanced Features\n *\n * Manages service worker lifecycle and offline capabilities\n */\n\nimport { medicalEventObserver, MEDICAL_EVENTS } from '../patterns/observer.js';\nimport { medicalPerformanceMonitor, PerformanceMetricType } from '../performance/medical-performance-monitor.js';\nimport { safeSetInnerHTML } from '../security/html-sanitizer.js';\n\n// Bulletproof error handling utilities\nimport {\n  safeAsync,\n  MedicalError,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  MEDICAL_ERROR_CODES,\n} from '../utils/error-handler.js';\n\n/**\n * Service Worker Manager Class\n */\nexport class MedicalServiceWorkerManager {\n  constructor() {\n    this.registration = null;\n    this.isOnline = navigator.onLine;\n    this.updateAvailable = false;\n    this.isUpdateCheckEnabled = true;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n\n    // Initialize event listeners\n    this.setupEventListeners();\n  }\n\n  /**\n   * Initialize service worker registration with bulletproof error handling\n   */\n  async initialize() {\n    return safeAsync(\n      async () => {\n        if (!('serviceWorker' in navigator)) {\n          throw new MedicalError(\n            'Service Worker not supported in this browser',\n            'SW_NOT_SUPPORTED',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.MEDIUM,\n          ).withContext({ userAgent: navigator.userAgent });\n        }\n\n        const metricId = medicalPerformanceMonitor.startMeasurement(\n          PerformanceMetricType.USER_INTERACTION,\n          'service_worker_registration',\n        );\n\n        try {\n          // Register service worker with timeout\n          const registrationPromise = navigator.serviceWorker.register(\n            '/0925/src/workers/medical-service-worker.js',\n            {\n              scope: '/0925/',\n              updateViaCache: 'none',\n            },\n          );\n\n          this.registration = await Promise.race([\n            registrationPromise,\n            new Promise((_, reject) => setTimeout(() => reject(new Error('Service Worker registration timeout')), 30000)),\n          ]);\n\n          if (!this.registration) {\n            throw new MedicalError(\n              'Service Worker registration returned null',\n              'SW_REGISTRATION_NULL',\n              ERROR_CATEGORIES.STORAGE,\n              ERROR_SEVERITY.HIGH,\n            );\n          }\n\n          // ('🏥 Medical Service Worker registered successfully');\n\n          // Setup components with error handling\n          await Promise.allSettled([\n            safeAsync(() => this.setupUpdateDetection(), null, { operation: 'setup_update_detection' }),\n            safeAsync(() => this.setupMessageHandler(), null, { operation: 'setup_message_handler' }),\n            safeAsync(() => this.checkForUpdates(), null, { operation: 'initial_update_check' }),\n          ]);\n\n          medicalPerformanceMonitor.endMeasurement(metricId, { success: true });\n\n          medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n            action: 'sw_registered',\n            scope: this.registration.scope,\n          });\n\n          return true;\n        } catch (error) {\n          medicalPerformanceMonitor.endMeasurement(metricId, {\n            success: false,\n            error: error.message,\n          });\n\n          throw error;\n        }\n      },\n      (error) => {\n        console.error('Service Worker initialization failed:', error.message);\n\n        medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n          action: 'sw_registration_failed',\n          error: error.message,\n          context: error.context || {},\n        });\n\n        return false;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        severity: ERROR_SEVERITY.MEDIUM,\n        timeout: 35000,\n        context: {\n          operation: 'service_worker_initialization',\n        },\n      },\n    );\n  }\n\n  /**\n   * Setup event listeners for online/offline detection\n   */\n  setupEventListeners() {\n    // Online/offline detection\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.handleOnlineStatusChange(true);\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.handleOnlineStatusChange(false);\n    });\n\n    // Page visibility for update checks\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden && this.isUpdateCheckEnabled) {\n        this.checkForUpdates();\n      }\n    });\n\n    // Periodic update checks\n    setInterval(() => {\n      if (this.isUpdateCheckEnabled && this.isOnline) {\n        this.checkForUpdates();\n      }\n    }, 5 * 60 * 1000); // Check every 5 minutes\n  }\n\n  /**\n   * Setup service worker update detection\n   */\n  setupUpdateDetection() {\n    if (!this.registration) {\n      return;\n    }\n\n    // Listen for new service worker installing\n    this.registration.addEventListener('updatefound', () => {\n      const newWorker = this.registration.installing;\n\n      newWorker.addEventListener('statechange', () => {\n        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n          // New update available\n          this.updateAvailable = true;\n          this.notifyUpdateAvailable();\n        }\n      });\n    });\n\n    // Listen for service worker taking control\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      window.location.reload();\n    });\n  }\n\n  /**\n   * Setup message handler for service worker communication\n   */\n  setupMessageHandler() {\n    navigator.serviceWorker.addEventListener('message', (event) => {\n      const { type, data } = event.data;\n\n      switch (type) {\n        case 'SW_INSTALLED':\n          this.handleServiceWorkerInstalled(data);\n          break;\n\n        case 'SW_ACTIVATED':\n          this.handleServiceWorkerActivated(data);\n          break;\n\n        case 'SW_INSTALL_ERROR':\n          this.handleServiceWorkerError(data);\n          break;\n\n        case 'MEDICAL_DATA_SYNCED':\n          this.handleMedicalDataSynced(data);\n          break;\n\n        default:\n          // ('Unknown service worker message:', type, data);\n      }\n    });\n  }\n\n  /**\n   * Handle online/offline status changes with error handling\n   */\n  handleOnlineStatusChange(isOnline) {\n    safeAsync(\n      async () => {\n        // (`🌐 Network status: ${isOnline ? 'Online' : 'Offline'}`);\n\n        medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n          action: 'network_status_changed',\n          isOnline,\n          timestamp: new Date().toISOString(),\n        });\n\n        // Show user notification with error handling\n        await safeAsync(\n          () => this.showNetworkStatusNotification(isOnline),\n          null,\n          { operation: 'show_network_notification' },\n        );\n\n        // Trigger background sync when coming back online\n        if (isOnline && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {\n          await safeAsync(\n            async () => {\n              const registration = await navigator.serviceWorker.ready;\n              if ('sync' in registration) {\n                return registration.sync.register('medical-data-sync');\n              }\n            },\n            (error) => {\n              console.warn('Background sync registration failed:', error.message);\n            },\n            {\n              operation: 'background_sync_registration',\n              timeout: 5000,\n            },\n          );\n        }\n      },\n      (error) => {\n        console.error('Error handling network status change:', error.message);\n      },\n      {\n        operation: 'handle_network_status_change',\n        isOnline,\n      },\n    );\n  }\n\n  /**\n   * Show network status notification to user with comprehensive error handling\n   */\n  showNetworkStatusNotification(isOnline) {\n    return safeAsync(\n      async () => {\n        if (!document || !document.body) {\n          throw new MedicalError(\n            'Document not available for notification',\n            'DOCUMENT_UNAVAILABLE',\n            ERROR_CATEGORIES.RENDERING,\n            ERROR_SEVERITY.LOW,\n          );\n        }\n\n        const notification = document.createElement('div');\n        if (!notification) {\n          throw new MedicalError(\n            'Failed to create notification element',\n            'ELEMENT_CREATION_FAILED',\n            ERROR_CATEGORIES.RENDERING,\n            ERROR_SEVERITY.LOW,\n          );\n        }\n\n        notification.className = `network-notification ${isOnline ? 'online' : 'offline'}`;\n\n        try {\n          safeSetInnerHTML(notification, `\n            <div class=\"notification-content\">\n              <span class=\"notification-icon\">${isOnline ? '🌐' : '📴'}</span>\n              <span class=\"notification-text\">\n                ${isOnline ? 'Connection restored' : 'Working offline'}\n              </span>\n            </div>\n          `);\n        } catch (htmlError) {\n          console.warn('Network notification sanitization failed, using fallback:', htmlError.message);\n          notification.textContent = isOnline ? '🌐 Connection restored' : '📴 Working offline';\n        }\n\n        // Check if body is still available before appending\n        if (!document.body) {\n          throw new MedicalError(\n            'Document body not available when appending notification',\n            'BODY_UNAVAILABLE',\n            ERROR_CATEGORIES.RENDERING,\n            ERROR_SEVERITY.LOW,\n          );\n        }\n\n        document.body.appendChild(notification);\n\n        // Auto-remove after 3 seconds with error handling\n        setTimeout(() => {\n          safeAsync(\n            () => {\n              if (notification && notification.parentNode) {\n                notification.parentNode.removeChild(notification);\n              }\n            },\n            null,\n            { operation: 'remove_notification' },\n          );\n        }, 3000);\n\n        return notification;\n      },\n      (error) => {\n        console.warn('Failed to show network status notification:', error.message);\n        // Try simple fallback notification\n        try {\n          if (console && console.info) {\n            console.info(`Network status: ${isOnline ? 'Online' : 'Offline'}`);\n          }\n        } catch (fallbackError) {\n          // Even console failed, nothing more we can do\n        }\n        return null;\n      },\n      {\n        operation: 'show_network_notification',\n        isOnline,\n      },\n    );\n  }\n\n  /**\n   * Check for service worker updates with bulletproof error handling\n   */\n  async checkForUpdates() {\n    return safeAsync(\n      async () => {\n        if (!this.registration) {\n          throw new MedicalError(\n            'No service worker registration available for update check',\n            'NO_REGISTRATION',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.LOW,\n          );\n        }\n\n        // Add timeout to update check\n        const updatePromise = this.registration.update();\n        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Update check timeout')), 10000));\n\n        await Promise.race([updatePromise, timeoutPromise]);\n\n        // Reset retry count on successful update check\n        this.retryCount = 0;\n\n        return true;\n      },\n      (error) => {\n        console.warn('Update check failed:', error.message);\n\n        this.retryCount++;\n        if (this.retryCount < this.maxRetries) {\n          // Exponential backoff for retries\n          const retryDelay = Math.min(5000 * 2 ** (this.retryCount - 1), 30000);\n\n          setTimeout(() => {\n            safeAsync(\n              () => this.checkForUpdates(),\n              null,\n              { operation: 'retry_update_check', retryCount: this.retryCount },\n            );\n          }, retryDelay);\n        } else {\n          console.error(`Update check failed after ${this.maxRetries} retries`);\n          medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n            action: 'sw_update_check_failed',\n            retryCount: this.retryCount,\n            error: error.message,\n          });\n        }\n\n        return false;\n      },\n      {\n        operation: 'service_worker_update_check',\n        retryCount: this.retryCount,\n      },\n    );\n  }\n\n  /**\n   * Apply available update\n   */\n  async applyUpdate() {\n    if (!this.updateAvailable || !this.registration) {\n      return;\n    }\n\n    try {\n      // Send message to service worker to skip waiting\n      if (this.registration.waiting) {\n        this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });\n      }\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'sw_update_applied',\n      });\n    } catch (error) {\n      // ('Failed to apply update:', error);\n    }\n  }\n\n  /**\n   * Notify user of available update\n   */\n  notifyUpdateAvailable() {\n    // ('📱 App update available');\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_update_available',\n    });\n\n    // Show update notification\n    this.showUpdateNotification();\n  }\n\n  /**\n   * Show update notification to user\n   */\n  showUpdateNotification() {\n    const notification = document.createElement('div');\n    notification.className = 'update-notification';\n    try {\n      safeSetInnerHTML(notification, `\n        <div class=\"notification-content\">\n          <span class=\"notification-icon\">🔄</span>\n          <span class=\"notification-text\">App update available</span>\n          <button class=\"update-button\" onclick=\"medicalSWManager.applyUpdate()\">\n            Update Now\n          </button>\n        </div>\n      `);\n    } catch (error) {\n      console.error('Update notification sanitization failed:', error);\n      // Safe fallback using textContent only\n      notification.textContent = '🔄 App update available. Please refresh to update.';\n    }\n\n    document.body.appendChild(notification);\n  }\n\n  /**\n   * Get cache status with timeout and error handling\n   */\n  async getCacheStatus() {\n    return safeAsync(\n      async () => {\n        if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n          throw new MedicalError(\n            'Service worker controller not available',\n            'NO_SW_CONTROLLER',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.LOW,\n          );\n        }\n\n        return new Promise((resolve, reject) => {\n          const channel = new MessageChannel();\n          const timeout = setTimeout(() => {\n            reject(new Error('Cache status request timeout'));\n          }, 5000);\n\n          channel.port1.onmessage = (event) => {\n            clearTimeout(timeout);\n            try {\n              // Validate response structure\n              if (!event.data || typeof event.data !== 'object') {\n                throw new Error('Invalid cache status response format');\n              }\n              resolve(event.data);\n            } catch (error) {\n              reject(error);\n            }\n          };\n\n          channel.port1.onerror = (error) => {\n            clearTimeout(timeout);\n            reject(new Error(`Message channel error: ${error.message || 'Unknown error'}`));\n          };\n\n          try {\n            navigator.serviceWorker.controller.postMessage(\n              { type: 'GET_CACHE_STATUS' },\n              [channel.port2],\n            );\n          } catch (postError) {\n            clearTimeout(timeout);\n            reject(new Error(`Failed to send cache status request: ${postError.message}`));\n          }\n        });\n      },\n      (error) => {\n        console.warn('Failed to get cache status:', error.message);\n        return {\n          error: true,\n          message: error.message,\n          timestamp: new Date().toISOString(),\n        };\n      },\n      {\n        operation: 'get_cache_status',\n      },\n    );\n  }\n\n  /**\n   * Clear all caches\n   */\n  async clearCaches() {\n    if (!navigator.serviceWorker.controller) {\n      return;\n    }\n\n    navigator.serviceWorker.controller.postMessage({\n      type: 'CLEAR_CACHE',\n    });\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_caches_cleared',\n    });\n  }\n\n  /**\n   * Prefetch resources for offline use\n   */\n  async prefetchResources(resources) {\n    if (!navigator.serviceWorker.controller) {\n      return;\n    }\n\n    navigator.serviceWorker.controller.postMessage({\n      type: 'PREFETCH_RESOURCES',\n      data: { resources },\n    });\n  }\n\n  /**\n   * Handle service worker installed event\n   */\n  handleServiceWorkerInstalled(data) {\n    // ('✅ Service Worker installed:', data);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_installed',\n      cacheVersion: data.cacheVersion,\n      criticalResourcesCount: data.criticalResourcesCount,\n    });\n  }\n\n  /**\n   * Handle service worker activated event\n   */\n  handleServiceWorkerActivated(data) {\n    // ('🚀 Service Worker activated:', data);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_activated',\n      cacheVersion: data.cacheVersion,\n      cleanedCaches: data.cleanedCaches,\n    });\n  }\n\n  /**\n   * Handle service worker error\n   */\n  handleServiceWorkerError(data) {\n    // ('❌ Service Worker error:', data);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_error',\n      error: data.error,\n    });\n  }\n\n  /**\n   * Handle medical data sync completion\n   */\n  handleMedicalDataSynced(data) {\n    // ('🔄 Medical data synced:', data);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'medical_data_synced',\n      timestamp: data.timestamp,\n    });\n  }\n\n  /**\n   * Get offline capabilities status\n   */\n  getOfflineStatus() {\n    return {\n      isOnline: this.isOnline,\n      serviceWorkerActive: !!navigator.serviceWorker.controller,\n      updateAvailable: this.updateAvailable,\n      cacheStatus: this.registration ? 'available' : 'unavailable',\n    };\n  }\n\n  /**\n   * Enable/disable automatic update checks\n   */\n  setUpdateCheckEnabled(enabled) {\n    this.isUpdateCheckEnabled = enabled;\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sw_update_check_toggled',\n      enabled,\n    });\n  }\n}\n\n/**\n * Install-time prompts for offline support\n */\nexport class OfflineInstallPrompt {\n  constructor(swManager) {\n    this.swManager = swManager;\n    this.installPromptEvent = null;\n    this.isInstallable = false;\n\n    this.setupInstallPrompt();\n  }\n\n  /**\n   * Setup PWA install prompt handling\n   */\n  setupInstallPrompt() {\n    // Listen for install prompt\n    window.addEventListener('beforeinstallprompt', (event) => {\n      event.preventDefault();\n      this.installPromptEvent = event;\n      this.isInstallable = true;\n\n      // ('📱 PWA install prompt available');\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'pwa_install_prompt_available',\n      });\n\n      // Show install banner after a delay\n      setTimeout(() => {\n        this.showInstallBanner();\n      }, 2000);\n    });\n\n    // Listen for app installed\n    window.addEventListener('appinstalled', () => {\n      // ('📱 PWA installed successfully');\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'pwa_installed',\n      });\n\n      this.hideInstallBanner();\n    });\n  }\n\n  /**\n   * Show PWA install banner\n   */\n  showInstallBanner() {\n    if (!this.isInstallable) {\n      return;\n    }\n\n    const banner = document.createElement('div');\n    banner.id = 'install-banner';\n    banner.className = 'install-banner';\n\n    // Create banner content manually to avoid HTML sanitization issues\n    const bannerContent = document.createElement('div');\n    bannerContent.className = 'banner-content';\n\n    const bannerText = document.createElement('div');\n    bannerText.className = 'banner-text';\n\n    const title = document.createElement('strong');\n    title.textContent = 'Install Stroke Triage Assistant';\n\n    const description = document.createElement('p');\n    description.textContent = 'Get offline access and faster performance';\n\n    bannerText.appendChild(title);\n    bannerText.appendChild(description);\n\n    const bannerActions = document.createElement('div');\n    bannerActions.className = 'banner-actions';\n\n    const installButton = document.createElement('button');\n    installButton.className = 'install-button';\n    installButton.textContent = 'Install';\n    installButton.addEventListener('click', () => {\n      this.promptInstall();\n    });\n\n    const dismissButton = document.createElement('button');\n    dismissButton.className = 'dismiss-button';\n    dismissButton.textContent = '×';\n    dismissButton.addEventListener('click', () => {\n      this.hideInstallBanner();\n    });\n\n    bannerActions.appendChild(installButton);\n    bannerActions.appendChild(dismissButton);\n\n    bannerContent.appendChild(bannerText);\n    bannerContent.appendChild(bannerActions);\n    banner.appendChild(bannerContent);\n\n    document.body.appendChild(banner);\n  }\n\n  /**\n   * Hide install banner\n   */\n  hideInstallBanner() {\n    const banner = document.getElementById('install-banner');\n    if (banner) {\n      banner.remove();\n    }\n  }\n\n  /**\n   * Prompt user to install PWA\n   */\n  async promptInstall() {\n    if (!this.installPromptEvent) {\n      return;\n    }\n\n    try {\n      const result = await this.installPromptEvent.prompt();\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'pwa_install_prompted',\n        outcome: result.outcome,\n      });\n\n      // Clear the install prompt\n      this.installPromptEvent = null;\n      this.isInstallable = false;\n\n      // Hide banner\n      this.hideInstallBanner();\n    } catch (error) {\n      // ('Install prompt failed:', error);\n    }\n  }\n}\n\n// Export singleton instances\nexport const medicalSWManager = new MedicalServiceWorkerManager();\nexport const offlineInstallPrompt = new OfflineInstallPrompt(medicalSWManager);\n\n// Make available globally for inline event handlers\nwindow.medicalSWManager = medicalSWManager;\nwindow.offlineInstallPrompt = offlineInstallPrompt;\n","/**\n * Medical Data Caching System\n * iGFAP Stroke Triage Assistant - Enterprise Caching Architecture\n *\n * Provides HIPAA-compliant caching with TTL and secure data handling\n */\n\nimport { medicalEventObserver, MEDICAL_EVENTS } from '../patterns/observer.js';\n\nimport { medicalPerformanceMonitor, PerformanceMetricType } from './medical-performance-monitor.js';\n\n/**\n * Cache storage types for different data sensitivity levels\n */\nexport const CacheStorageType = {\n  MEMORY: 'memory',\n  SESSION: 'session',\n  LOCAL: 'local',\n  INDEXED_DB: 'indexed_db',\n};\n\n/**\n * Cache entry priorities for medical data\n */\nexport const CachePriority = {\n  CRITICAL: 'critical', // Emergency data, never evict\n  HIGH: 'high', // Important medical data\n  NORMAL: 'normal', // Standard application data\n  LOW: 'low', // Non-critical data, evict first\n};\n\n/**\n * Default TTL values for different types of medical data (in milliseconds)\n */\nexport const MedicalCacheTTL = {\n  PATIENT_DATA: 30 * 60 * 1000, // 30 minutes\n  PREDICTION_RESULTS: 60 * 60 * 1000, // 1 hour\n  VALIDATION_RULES: 24 * 60 * 60 * 1000, // 24 hours\n  API_RESPONSES: 15 * 60 * 1000, // 15 minutes\n  UI_STATE: 10 * 60 * 1000, // 10 minutes\n  STATIC_CONFIG: 7 * 24 * 60 * 60 * 1000, // 7 days\n};\n\n/**\n * Cache entry with metadata and security features\n */\nclass CacheEntry {\n  constructor(key, value, ttl, priority = CachePriority.NORMAL, metadata = {}) {\n    this.key = key;\n    this.value = this.sanitizeValue(value);\n    this.ttl = ttl;\n    this.priority = priority;\n    this.metadata = {\n      ...metadata,\n      createdAt: Date.now(),\n      accessCount: 0,\n      lastAccessed: Date.now(),\n    };\n    this.expiresAt = ttl > 0 ? Date.now() + ttl : null;\n    this.encrypted = false;\n  }\n\n  /**\n   * Sanitize sensitive data before caching\n   */\n  sanitizeValue(value) {\n    if (typeof value !== 'object' || value === null) {\n      return value;\n    }\n\n    // Deep clone to avoid reference issues\n    const sanitized = JSON.parse(JSON.stringify(value));\n\n    // Remove or mask sensitive fields\n    const sensitiveFields = ['ssn', 'mrn', 'patient_id', 'user_id', 'session_token'];\n    this.removeSensitiveFields(sanitized, sensitiveFields);\n\n    return sanitized;\n  }\n\n  /**\n   * Recursively remove sensitive fields\n   */\n  removeSensitiveFields(obj, sensitiveFields) {\n    Object.keys(obj).forEach((key) => {\n      if (sensitiveFields.some((field) => key.toLowerCase().includes(field))) {\n        obj[key] = '[REDACTED]';\n      } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n        this.removeSensitiveFields(obj[key], sensitiveFields);\n      }\n    });\n  }\n\n  /**\n   * Check if cache entry has expired\n   */\n  isExpired() {\n    return this.expiresAt !== null && Date.now() > this.expiresAt;\n  }\n\n  /**\n   * Mark entry as accessed\n   */\n  markAccessed() {\n    this.metadata.accessCount += 1;\n    this.metadata.lastAccessed = Date.now();\n  }\n\n  /**\n   * Get entry age in milliseconds\n   */\n  getAge() {\n    return Date.now() - this.metadata.createdAt;\n  }\n\n  /**\n   * Get time until expiration\n   */\n  getTimeToExpiration() {\n    if (this.expiresAt === null) {\n      return Infinity;\n    }\n    return Math.max(0, this.expiresAt - Date.now());\n  }\n\n  /**\n   * Calculate entry score for eviction (lower score = evict first)\n   */\n  getEvictionScore() {\n    const priorityWeights = {\n      [CachePriority.CRITICAL]: 1000,\n      [CachePriority.HIGH]: 100,\n      [CachePriority.NORMAL]: 10,\n      [CachePriority.LOW]: 1,\n    };\n\n    const priorityWeight = priorityWeights[this.priority] || 1;\n    const accessWeight = Math.log(this.metadata.accessCount + 1);\n    const ageWeight = 1 / (this.getAge() + 1);\n\n    return priorityWeight * accessWeight * ageWeight;\n  }\n}\n\n/**\n * Medical Cache Manager with HIPAA compliance\n */\nexport class MedicalCache {\n  constructor(storageType = CacheStorageType.MEMORY, options = {}) {\n    this.storageType = storageType;\n    this.options = {\n      maxSize: 100 * 1024 * 1024, // 100MB max cache size\n      maxEntries: 1000, // Maximum number of entries\n      cleanupInterval: 5 * 60 * 1000, // Cleanup every 5 minutes\n      enableEncryption: false, // Enable for sensitive data\n      enableMetrics: true,\n      ...options,\n    };\n\n    this.cache = new Map();\n    this.cleanupTimer = null;\n    this.totalSize = 0;\n    this.hitCount = 0;\n    this.missCount = 0;\n    this.evictionCount = 0;\n\n    this.initializeStorage();\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Initialize storage backend\n   */\n  initializeStorage() {\n    switch (this.storageType) {\n      case CacheStorageType.SESSION:\n        this.storage = sessionStorage;\n        this.loadFromStorage();\n        break;\n      case CacheStorageType.LOCAL:\n        this.storage = localStorage;\n        this.loadFromStorage();\n        break;\n      case CacheStorageType.INDEXED_DB:\n        this.initializeIndexedDB();\n        break;\n      default:\n        this.storage = null; // Memory only\n    }\n  }\n\n  /**\n   * Load cache from storage\n   */\n  loadFromStorage() {\n    if (!this.storage) {\n      return;\n    }\n\n    try {\n      const cacheData = this.storage.getItem('medical_cache');\n      if (cacheData) {\n        const parsed = JSON.parse(cacheData);\n        Object.entries(parsed).forEach(([key, entryData]) => {\n          const entry = new CacheEntry(\n            entryData.key,\n            entryData.value,\n            entryData.ttl,\n            entryData.priority,\n            entryData.metadata,\n          );\n          entry.expiresAt = entryData.expiresAt;\n\n          if (!entry.isExpired()) {\n            this.cache.set(key, entry);\n            this.totalSize += this.calculateSize(entry.value);\n          }\n        });\n      }\n    } catch (error) {\n      // ('Failed to load cache from storage:', error.message);\n    }\n  }\n\n  /**\n   * Save cache to storage\n   */\n  saveToStorage() {\n    if (!this.storage) {\n      return;\n    }\n\n    try {\n      const cacheData = {};\n      this.cache.forEach((entry, key) => {\n        cacheData[key] = {\n          key: entry.key,\n          value: entry.value,\n          ttl: entry.ttl,\n          priority: entry.priority,\n          metadata: entry.metadata,\n          expiresAt: entry.expiresAt,\n        };\n      });\n\n      this.storage.setItem('medical_cache', JSON.stringify(cacheData));\n    } catch (error) {\n      // ('Failed to save cache to storage:', error.message);\n    }\n  }\n\n  /**\n   * Initialize IndexedDB for large data caching\n   */\n  async initializeIndexedDB() {\n    // IndexedDB implementation for future enhancement\n    // ('IndexedDB cache initialization planned for future implementation');\n  }\n\n  /**\n   * Set cache entry\n   */\n  set(key, value, ttl = MedicalCacheTTL.API_RESPONSES, priority = CachePriority.NORMAL, metadata = {}) {\n    const metricId = medicalPerformanceMonitor.startMeasurement(\n      PerformanceMetricType.CACHE,\n      'cache_set',\n      { key, priority },\n    );\n\n    try {\n      // Check if we need to make space\n      this.ensureCapacity();\n\n      const entry = new CacheEntry(key, value, ttl, priority, metadata);\n      const size = this.calculateSize(value);\n\n      // Remove existing entry if present\n      if (this.cache.has(key)) {\n        const oldEntry = this.cache.get(key);\n        this.totalSize -= this.calculateSize(oldEntry.value);\n      }\n\n      this.cache.set(key, entry);\n      this.totalSize += size;\n\n      // Save to persistent storage\n      if (this.storageType !== CacheStorageType.MEMORY) {\n        this.saveToStorage();\n      }\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'cache_set',\n        key,\n        size,\n        ttl,\n        priority,\n      });\n\n      medicalPerformanceMonitor.endMeasurement(metricId, { success: true });\n      return true;\n    } catch (error) {\n      medicalPerformanceMonitor.endMeasurement(metricId, { success: false, error: error.message });\n      // ('Cache set error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get cache entry\n   */\n  get(key) {\n    const metricId = medicalPerformanceMonitor.startMeasurement(\n      PerformanceMetricType.CACHE,\n      'cache_get',\n      { key },\n    );\n\n    try {\n      const entry = this.cache.get(key);\n\n      if (!entry) {\n        this.missCount += 1;\n        medicalPerformanceMonitor.endMeasurement(metricId, { hit: false });\n        return null;\n      }\n\n      if (entry.isExpired()) {\n        this.cache.delete(key);\n        this.totalSize -= this.calculateSize(entry.value);\n        this.missCount += 1;\n        medicalPerformanceMonitor.endMeasurement(metricId, { hit: false, expired: true });\n        return null;\n      }\n\n      entry.markAccessed();\n      this.hitCount += 1;\n\n      medicalPerformanceMonitor.endMeasurement(metricId, { hit: true });\n      return entry.value;\n    } catch (error) {\n      medicalPerformanceMonitor.endMeasurement(metricId, { hit: false, error: error.message });\n      // ('Cache get error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if key exists and is not expired\n   */\n  has(key) {\n    const entry = this.cache.get(key);\n    return entry && !entry.isExpired();\n  }\n\n  /**\n   * Delete cache entry\n   */\n  delete(key) {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.totalSize -= this.calculateSize(entry.value);\n      this.cache.delete(key);\n\n      if (this.storageType !== CacheStorageType.MEMORY) {\n        this.saveToStorage();\n      }\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'cache_delete',\n        key,\n      });\n\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear() {\n    const entriesCleared = this.cache.size;\n    this.cache.clear();\n    this.totalSize = 0;\n\n    if (this.storage) {\n      this.storage.removeItem('medical_cache');\n    }\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'cache_cleared',\n      entriesCleared,\n    });\n  }\n\n  /**\n   * Ensure cache capacity by evicting entries\n   */\n  ensureCapacity() {\n    // Check size limit\n    while (this.totalSize > this.options.maxSize) {\n      this.evictLeastImportant();\n    }\n\n    // Check entry count limit\n    while (this.cache.size >= this.options.maxEntries) {\n      this.evictLeastImportant();\n    }\n  }\n\n  /**\n   * Evict least important entry based on priority and access patterns\n   */\n  evictLeastImportant() {\n    let lowestScore = Infinity;\n    let keyToEvict = null;\n\n    this.cache.forEach((entry, key) => {\n      // Never evict critical priority items unless expired\n      if (entry.priority === CachePriority.CRITICAL && !entry.isExpired()) {\n        return;\n      }\n\n      const score = entry.getEvictionScore();\n      if (score < lowestScore) {\n        lowestScore = score;\n        keyToEvict = key;\n      }\n    });\n\n    if (keyToEvict) {\n      this.delete(keyToEvict);\n      this.evictionCount += 1;\n    }\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const startTime = performance.now();\n    let cleanedCount = 0;\n\n    this.cache.forEach((entry, key) => {\n      if (entry.isExpired()) {\n        this.delete(key);\n        cleanedCount += 1;\n      }\n    });\n\n    const duration = performance.now() - startTime;\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'cache_cleanup',\n      cleanedCount,\n      duration,\n      remainingEntries: this.cache.size,\n    });\n\n    return cleanedCount;\n  }\n\n  /**\n   * Start automatic cleanup timer\n   */\n  startCleanupTimer() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n\n    this.cleanupTimer = setInterval(() => {\n      this.cleanup();\n    }, this.options.cleanupInterval);\n  }\n\n  /**\n   * Stop cleanup timer\n   */\n  stopCleanupTimer() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n\n  /**\n   * Calculate size of cached value (approximate)\n   */\n  calculateSize(value) {\n    try {\n      return JSON.stringify(value).length * 2; // Rough estimate (UTF-16)\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    const hitRate = this.hitCount + this.missCount > 0\n      ? (this.hitCount / (this.hitCount + this.missCount)) * 100\n      : 0;\n\n    return {\n      entries: this.cache.size,\n      totalSize: this.totalSize,\n      maxSize: this.options.maxSize,\n      hitCount: this.hitCount,\n      missCount: this.missCount,\n      hitRate: `${hitRate.toFixed(2)}%`,\n      evictionCount: this.evictionCount,\n      storageType: this.storageType,\n      utilizationPercent: `${((this.totalSize / this.options.maxSize) * 100).toFixed(2)}%`,\n    };\n  }\n\n  /**\n   * Get cache entry information\n   */\n  getEntryInfo(key) {\n    const entry = this.cache.get(key);\n    if (!entry) {\n      return null;\n    }\n\n    return {\n      key: entry.key,\n      size: this.calculateSize(entry.value),\n      priority: entry.priority,\n      ttl: entry.ttl,\n      age: entry.getAge(),\n      timeToExpiration: entry.getTimeToExpiration(),\n      accessCount: entry.metadata.accessCount,\n      lastAccessed: new Date(entry.metadata.lastAccessed).toISOString(),\n      isExpired: entry.isExpired(),\n      evictionScore: entry.getEvictionScore(),\n    };\n  }\n\n  /**\n   * Dispose of cache and cleanup resources\n   */\n  dispose() {\n    this.stopCleanupTimer();\n    this.clear();\n  }\n}\n\n/**\n * Medical cache factory for different data types\n */\nexport class MedicalCacheFactory {\n  static patientDataCache = null;\n\n  static predictionCache = null;\n\n  static validationCache = null;\n\n  static apiCache = null;\n\n  /**\n   * Get or create patient data cache (session storage, short TTL)\n   */\n  static getPatientDataCache() {\n    if (!this.patientDataCache) {\n      this.patientDataCache = new MedicalCache(CacheStorageType.SESSION, {\n        maxSize: 10 * 1024 * 1024, // 10MB\n        maxEntries: 100,\n        enableEncryption: true,\n      });\n    }\n    return this.patientDataCache;\n  }\n\n  /**\n   * Get or create prediction results cache (memory only, medium TTL)\n   */\n  static getPredictionCache() {\n    if (!this.predictionCache) {\n      this.predictionCache = new MedicalCache(CacheStorageType.MEMORY, {\n        maxSize: 50 * 1024 * 1024, // 50MB\n        maxEntries: 500,\n      });\n    }\n    return this.predictionCache;\n  }\n\n  /**\n   * Get or create validation rules cache (local storage, long TTL)\n   */\n  static getValidationCache() {\n    if (!this.validationCache) {\n      this.validationCache = new MedicalCache(CacheStorageType.LOCAL, {\n        maxSize: 5 * 1024 * 1024, // 5MB\n        maxEntries: 200,\n      });\n    }\n    return this.validationCache;\n  }\n\n  /**\n   * Get or create API response cache (session storage, short TTL)\n   */\n  static getApiCache() {\n    if (!this.apiCache) {\n      this.apiCache = new MedicalCache(CacheStorageType.SESSION, {\n        maxSize: 20 * 1024 * 1024, // 20MB\n        maxEntries: 300,\n      });\n    }\n    return this.apiCache;\n  }\n\n  /**\n   * Clear all caches (privacy compliance)\n   */\n  static clearAllCaches() {\n    [\n      this.patientDataCache,\n      this.predictionCache,\n      this.validationCache,\n      this.apiCache,\n    ].forEach((cache) => {\n      if (cache) {\n        cache.clear();\n      }\n    });\n  }\n\n  /**\n   * Dispose all caches\n   */\n  static disposeAllCaches() {\n    [\n      this.patientDataCache,\n      this.predictionCache,\n      this.validationCache,\n      this.apiCache,\n    ].forEach((cache) => {\n      if (cache) {\n        cache.dispose();\n      }\n    });\n\n    this.patientDataCache = null;\n    this.predictionCache = null;\n    this.validationCache = null;\n    this.apiCache = null;\n  }\n}\n\n// Export convenience instances\nexport const patientDataCache = MedicalCacheFactory.getPatientDataCache();\nexport const predictionCache = MedicalCacheFactory.getPredictionCache();\nexport const validationCache = MedicalCacheFactory.getValidationCache();\nexport const apiCache = MedicalCacheFactory.getApiCache();\n","/**\n * Medical Data Synchronization Manager\n * iGFAP Stroke Triage Assistant - Phase 3 Advanced Features\n *\n * Provides real-time data synchronization with conflict resolution\n */\n\nimport { medicalEventObserver, MEDICAL_EVENTS } from '../patterns/observer.js';\nimport { medicalPerformanceMonitor, PerformanceMetricType } from '../performance/medical-performance-monitor.js';\nimport { patientDataCache, MedicalCacheTTL, CachePriority } from '../performance/medical-cache.js';\nimport { store } from '../state/store.js';\n\n// Bulletproof error handling utilities\nimport {\n  safeAsync,\n  MedicalError,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  MEDICAL_ERROR_CODES,\n} from '../utils/error-handler.js';\n\n/**\n * Sync operation types\n */\nexport const SyncOperationType = {\n  CREATE: 'create',\n  UPDATE: 'update',\n  DELETE: 'delete',\n  CONFLICT_RESOLVE: 'conflict_resolve',\n};\n\n/**\n * Sync status states\n */\nexport const SyncStatus = {\n  IDLE: 'idle',\n  SYNCING: 'syncing',\n  ERROR: 'error',\n  CONFLICT: 'conflict',\n  OFFLINE: 'offline',\n};\n\n/**\n * Data conflict resolution strategies\n */\nexport const ConflictResolution = {\n  CLIENT_WINS: 'client_wins',\n  SERVER_WINS: 'server_wins',\n  MERGE: 'merge',\n  MANUAL: 'manual',\n};\n\n/**\n * Medical sync operation wrapper\n */\nclass MedicalSyncOperation {\n  constructor(type, entityType, entityId, data, timestamp = Date.now()) {\n    this.id = `sync_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;\n    this.type = type;\n    this.entityType = entityType;\n    this.entityId = entityId;\n    this.data = data;\n    this.timestamp = timestamp;\n    this.attempts = 0;\n    this.maxAttempts = 3;\n    this.status = 'pending';\n    this.error = null;\n  }\n\n  /**\n   * Check if operation should be retried\n   */\n  canRetry() {\n    return this.attempts < this.maxAttempts && this.status === 'error';\n  }\n\n  /**\n   * Mark operation as failed\n   */\n  markFailed(error) {\n    this.status = 'error';\n    this.error = error;\n    this.attempts += 1;\n  }\n\n  /**\n   * Mark operation as completed\n   */\n  markCompleted() {\n    this.status = 'completed';\n    this.error = null;\n  }\n}\n\n/**\n * Medical Data Synchronization Manager\n */\nexport class MedicalSyncManager {\n  constructor() {\n    this.status = SyncStatus.IDLE;\n    this.pendingOperations = new Map();\n    this.conflictQueue = new Map();\n    this.syncInterval = null;\n    this.isOnline = navigator.onLine;\n    this.lastSyncTime = null;\n    this.syncInProgress = false;\n\n    // Configuration\n    this.config = {\n      syncIntervalMs: 30000, // 30 seconds\n      conflictRetentionMs: 24 * 60 * 60 * 1000, // 24 hours\n      maxPendingOperations: 100,\n      enableRealTimeSync: true,\n      enableConflictResolution: true,\n    };\n\n    this.setupEventListeners();\n  }\n\n  /**\n   * Initialize synchronization manager with bulletproof error handling\n   */\n  async initialize() {\n    return safeAsync(\n      async () => {\n        // ('🔄 Initializing Medical Sync Manager...');\n\n        // Load pending operations from storage with error handling\n        await safeAsync(\n          () => this.loadPendingOperations(),\n          (error) => {\n            console.warn('Failed to load pending operations, starting fresh:', error.message);\n            this.pendingOperations.clear();\n          },\n          { operation: 'load_pending_operations' },\n        );\n\n        // Start periodic sync if online\n        if (this.isOnline && this.config.enableRealTimeSync) {\n          await safeAsync(\n            () => this.startPeriodicSync(),\n            null,\n            { operation: 'start_periodic_sync' },\n          );\n        }\n\n        // Perform initial sync with error handling\n        await safeAsync(\n          () => this.performSync(),\n          (error) => {\n            console.warn('Initial sync failed, will retry later:', error.message);\n          },\n          { operation: 'initial_sync' },\n        );\n\n        medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n          action: 'sync_manager_initialized',\n          pendingOperations: this.pendingOperations.size,\n        });\n\n        // ('✅ Medical Sync Manager initialized');\n        return true;\n      },\n      (error) => {\n        console.error('Sync Manager initialization failed:', error.message);\n\n        medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n          action: 'sync_manager_initialization_failed',\n          error: error.message,\n        });\n\n        return false;\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        severity: ERROR_SEVERITY.MEDIUM,\n        timeout: 30000,\n        context: {\n          operation: 'sync_manager_initialization',\n        },\n      },\n    );\n  }\n\n  /**\n   * Setup event listeners\n   */\n  setupEventListeners() {\n    // Online/offline status\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.handleConnectionChange(true);\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.handleConnectionChange(false);\n    });\n\n    // Listen for data changes that need syncing\n    medicalEventObserver.subscribe(MEDICAL_EVENTS.PATIENT_DATA_UPDATED, (event) => {\n      this.queueDataSync('patient_data', event.fieldName, event);\n    });\n\n    medicalEventObserver.subscribe(MEDICAL_EVENTS.PREDICTION_COMPLETED, (event) => {\n      this.queueDataSync('prediction_result', event.module, event);\n    });\n\n    // Page visibility for sync optimization\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden && this.isOnline) {\n        this.performSync();\n      }\n    });\n  }\n\n  /**\n   * Handle connection status changes\n   */\n  async handleConnectionChange(isOnline) {\n    // (`🌐 Connection status changed: ${isOnline ? 'Online' : 'Offline'}`);\n\n    this.status = isOnline ? SyncStatus.IDLE : SyncStatus.OFFLINE;\n\n    if (isOnline) {\n      // Connection restored - start syncing\n      this.startPeriodicSync();\n      await this.performSync();\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'sync_connection_restored',\n        pendingOperations: this.pendingOperations.size,\n      });\n    } else {\n      // Connection lost - stop periodic sync\n      this.stopPeriodicSync();\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: 'sync_connection_lost',\n      });\n    }\n  }\n\n  /**\n   * Queue data for synchronization\n   */\n  queueDataSync(entityType, entityId, data) {\n    if (!this.config.enableRealTimeSync) {\n      return;\n    }\n\n    const operation = new MedicalSyncOperation(\n      SyncOperationType.UPDATE,\n      entityType,\n      entityId,\n      this.sanitizeDataForSync(data),\n    );\n\n    // Prevent queue overflow\n    if (this.pendingOperations.size >= this.config.maxPendingOperations) {\n      const oldestKey = this.pendingOperations.keys().next().value;\n      this.pendingOperations.delete(oldestKey);\n    }\n\n    this.pendingOperations.set(operation.id, operation);\n\n    // Save to persistent storage\n    this.savePendingOperations();\n\n    // Trigger immediate sync if online\n    if (this.isOnline && !this.syncInProgress) {\n      setTimeout(() => this.performSync(), 1000); // Small delay to batch operations\n    }\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_operation_queued',\n      entityType,\n      entityId,\n      operationId: operation.id,\n    });\n  }\n\n  /**\n   * Sanitize sensitive data before sync\n   */\n  sanitizeDataForSync(data) {\n    const sanitized = { ...data };\n\n    // Remove sensitive fields\n    const sensitiveFields = ['ssn', 'mrn', 'patient_id', 'user_id', 'session_token'];\n    sensitiveFields.forEach((field) => {\n      if (sanitized[field]) {\n        delete sanitized[field];\n      }\n    });\n\n    // Add sync metadata\n    sanitized._syncTimestamp = Date.now();\n    sanitized._syncId = `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    return sanitized;\n  }\n\n  /**\n   * Perform synchronization of pending operations with comprehensive error handling\n   */\n  async performSync() {\n    return safeAsync(\n      async () => {\n        if (!this.isOnline || this.syncInProgress || this.pendingOperations.size === 0) {\n          return {\n            skipped: true,\n            reason: !this.isOnline ? 'offline' : this.syncInProgress ? 'already_syncing' : 'no_operations',\n          };\n        }\n\n        const metricId = medicalPerformanceMonitor.startMeasurement(\n          PerformanceMetricType.NETWORK,\n          'medical_data_sync',\n        );\n\n        this.syncInProgress = true;\n        this.status = SyncStatus.SYNCING;\n\n        // (`🔄 Starting sync of ${this.pendingOperations.size} operations...`);\n\n        let completedCount = 0;\n        let errorCount = 0;\n        let conflictCount = 0;\n        const startTime = Date.now();\n\n        try {\n          // Process operations in batches with timeout\n          const operations = Array.from(this.pendingOperations.values());\n          const batchSize = 5;\n          const maxSyncTime = 120000; // 2 minutes max sync time\n\n          for (let i = 0; i < operations.length; i += batchSize) {\n            // Check timeout\n            if (Date.now() - startTime > maxSyncTime) {\n              throw new MedicalError(\n                'Sync operation timeout',\n                'SYNC_TIMEOUT',\n                ERROR_CATEGORIES.NETWORK,\n                ERROR_SEVERITY.MEDIUM,\n              ).withContext({ processedBatches: Math.floor(i / batchSize), totalBatches: Math.ceil(operations.length / batchSize) });\n            }\n\n            const batch = operations.slice(i, i + batchSize);\n            const results = await safeAsync(\n              () => this.processSyncBatch(batch),\n              (error) => {\n                console.warn(`Batch ${Math.floor(i / batchSize)} sync failed:`, error.message);\n                return batch.map((op) => ({\n                  operationId: op.id,\n                  status: 'error',\n                  error: error.message,\n                }));\n              },\n              {\n                operation: 'process_sync_batch',\n                batchIndex: Math.floor(i / batchSize),\n                timeout: 30000,\n              },\n            );\n\n            results.forEach((result) => {\n              if (result.status === 'completed') {\n                completedCount++;\n                this.pendingOperations.delete(result.operationId);\n              } else if (result.status === 'conflict') {\n                conflictCount++;\n                safeAsync(\n                  () => this.handleSyncConflict(result),\n                  null,\n                  { operation: 'handle_sync_conflict' },\n                );\n              } else {\n                errorCount++;\n              }\n            });\n          }\n\n          this.lastSyncTime = Date.now();\n\n          // Save updated pending operations with error handling\n          await safeAsync(\n            () => this.savePendingOperations(),\n            (error) => {\n              console.warn('Failed to save pending operations after sync:', error.message);\n            },\n            { operation: 'save_pending_operations_after_sync' },\n          );\n\n          // (`✅ Sync completed: ${completedCount} success, ${errorCount} errors, ${conflictCount} conflicts`);\n\n          medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n            action: 'sync_completed',\n            completedCount,\n            errorCount,\n            conflictCount,\n            duration: Date.now() - startTime,\n          });\n\n          medicalPerformanceMonitor.endMeasurement(metricId, {\n            success: true,\n            operationsProcessed: completedCount + errorCount + conflictCount,\n          });\n\n          return {\n            success: true,\n            completedCount,\n            errorCount,\n            conflictCount,\n            duration: Date.now() - startTime,\n          };\n        } catch (error) {\n          medicalPerformanceMonitor.endMeasurement(metricId, {\n            success: false,\n            error: error.message,\n          });\n\n          this.status = SyncStatus.ERROR;\n          throw error;\n        } finally {\n          this.syncInProgress = false;\n          this.status = this.pendingOperations.size > 0 ? SyncStatus.IDLE : SyncStatus.IDLE;\n        }\n      },\n      (error) => {\n        console.error('Sync operation failed:', error.message);\n\n        medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n          action: 'sync_failed',\n          error: error.message,\n          pendingOperations: this.pendingOperations.size,\n        });\n\n        this.status = SyncStatus.ERROR;\n\n        return {\n          success: false,\n          error: error.message,\n        };\n      },\n      {\n        category: ERROR_CATEGORIES.NETWORK,\n        severity: ERROR_SEVERITY.MEDIUM,\n        timeout: 150000, // 2.5 minutes\n        context: {\n          operation: 'perform_sync',\n          pendingOperations: this.pendingOperations.size,\n        },\n      },\n    );\n  }\n\n  /**\n   * Process a batch of sync operations\n   */\n  async processSyncBatch(operations) {\n    const results = [];\n\n    // Simulate sync operations (in real implementation, these would be API calls)\n    for (const operation of operations) {\n      try {\n        const result = await this.executeSyncOperation(operation);\n        results.push({\n          operationId: operation.id,\n          status: 'completed',\n          result,\n        });\n\n        operation.markCompleted();\n      } catch (error) {\n        if (error.name === 'ConflictError') {\n          results.push({\n            operationId: operation.id,\n            status: 'conflict',\n            conflict: error.conflict,\n            operation,\n          });\n        } else {\n          operation.markFailed(error.message);\n\n          if (operation.canRetry()) {\n            // (`⚠️ Operation ${operation.id} failed, will retry: ${error.message}`);\n          } else {\n            // (`❌ Operation ${operation.id} failed permanently: ${error.message}`);\n            this.pendingOperations.delete(operation.id);\n          }\n\n          results.push({\n            operationId: operation.id,\n            status: 'error',\n            error: error.message,\n          });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute a single sync operation\n   */\n  async executeSyncOperation(operation) {\n    // Simulate API call with realistic delay and error handling\n    await new Promise((resolve) => setTimeout(resolve, 100 + Math.random() * 200));\n\n    // Simulate conflict detection (5% chance)\n    if (Math.random() < 0.05) {\n      const conflict = {\n        clientData: operation.data,\n        serverData: { ...operation.data, _serverModified: true },\n        conflictFields: ['timestamp', 'value'],\n        resolution: ConflictResolution.MANUAL,\n      };\n\n      const error = new Error('Data conflict detected');\n      error.name = 'ConflictError';\n      error.conflict = conflict;\n      throw error;\n    }\n\n    // Simulate network error (2% chance)\n    if (Math.random() < 0.02) {\n      throw new Error('Network request failed');\n    }\n\n    // Successful sync\n    return {\n      entityType: operation.entityType,\n      entityId: operation.entityId,\n      syncTimestamp: Date.now(),\n      serverVersion: Date.now(),\n    };\n  }\n\n  /**\n   * Handle sync conflicts\n   */\n  handleSyncConflict(conflictResult) {\n    const { operation, conflict } = conflictResult;\n\n    // Store conflict for manual resolution\n    this.conflictQueue.set(operation.id, {\n      operation,\n      conflict,\n      timestamp: Date.now(),\n    });\n\n    this.status = SyncStatus.CONFLICT;\n\n    // Apply automatic resolution if configured\n    if (this.config.enableConflictResolution) {\n      this.resolveConflictAutomatically(operation.id, conflict);\n    }\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_conflict_detected',\n      operationId: operation.id,\n      entityType: operation.entityType,\n      conflictFields: conflict.conflictFields,\n    });\n  }\n\n  /**\n   * Resolve conflicts automatically based on strategy\n   */\n  async resolveConflictAutomatically(conflictId, conflict) {\n    let resolvedData;\n\n    switch (conflict.resolution) {\n      case ConflictResolution.CLIENT_WINS:\n        resolvedData = conflict.clientData;\n        break;\n\n      case ConflictResolution.SERVER_WINS:\n        resolvedData = conflict.serverData;\n        break;\n\n      case ConflictResolution.MERGE:\n        resolvedData = this.mergeConflictData(conflict.clientData, conflict.serverData);\n        break;\n\n      default:\n        // Manual resolution required\n        return;\n    }\n\n    // Create resolution operation\n    const resolutionOperation = new MedicalSyncOperation(\n      SyncOperationType.CONFLICT_RESOLVE,\n      'conflict_resolution',\n      conflictId,\n      resolvedData,\n    );\n\n    this.pendingOperations.set(resolutionOperation.id, resolutionOperation);\n    this.conflictQueue.delete(conflictId);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_conflict_auto_resolved',\n      conflictId,\n      resolution: conflict.resolution,\n    });\n  }\n\n  /**\n   * Merge conflicting data intelligently\n   */\n  mergeConflictData(clientData, serverData) {\n    const merged = { ...serverData };\n\n    // Prefer client data for user-entered fields\n    const clientPreferredFields = ['gfap_value', 'age_years', 'systolic_bp', 'diastolic_bp'];\n    clientPreferredFields.forEach((field) => {\n      if (clientData[field] !== undefined) {\n        merged[field] = clientData[field];\n      }\n    });\n\n    // Use latest timestamp\n    merged._mergedAt = Date.now();\n    merged._mergeStrategy = 'intelligent_merge';\n\n    return merged;\n  }\n\n  /**\n   * Start periodic synchronization\n   */\n  startPeriodicSync() {\n    if (this.syncInterval) {\n      return;\n    }\n\n    this.syncInterval = setInterval(() => {\n      if (this.isOnline && this.pendingOperations.size > 0) {\n        this.performSync();\n      }\n    }, this.config.syncIntervalMs);\n\n    // (`🔄 Periodic sync started (${this.config.syncIntervalMs}ms interval)`);\n  }\n\n  /**\n   * Stop periodic synchronization\n   */\n  stopPeriodicSync() {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n      // ('⏹️ Periodic sync stopped');\n    }\n  }\n\n  /**\n   * Force immediate synchronization\n   */\n  async forcSync() {\n    if (!this.isOnline) {\n      throw new Error('Cannot sync while offline');\n    }\n\n    this.stopPeriodicSync();\n    await this.performSync();\n    this.startPeriodicSync();\n  }\n\n  /**\n   * Get synchronization status\n   */\n  getSyncStatus() {\n    return {\n      status: this.status,\n      isOnline: this.isOnline,\n      pendingOperations: this.pendingOperations.size,\n      conflicts: this.conflictQueue.size,\n      lastSyncTime: this.lastSyncTime,\n      syncInProgress: this.syncInProgress,\n    };\n  }\n\n  /**\n   * Load pending operations from storage with comprehensive error handling\n   */\n  async loadPendingOperations() {\n    return safeAsync(\n      async () => {\n        if (typeof localStorage === 'undefined') {\n          throw new MedicalError(\n            'Local storage not available',\n            'STORAGE_UNAVAILABLE',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.MEDIUM,\n          );\n        }\n\n        const stored = localStorage.getItem('medical_sync_pending');\n        if (!stored) {\n          // ('No pending sync operations found');\n          return { loaded: 0 };\n        }\n\n        let operations;\n        try {\n          operations = JSON.parse(stored);\n        } catch (parseError) {\n          throw new MedicalError(\n            'Failed to parse stored sync operations',\n            'PARSE_ERROR',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.MEDIUM,\n          ).withContext({ parseError: parseError.message });\n        }\n\n        if (!Array.isArray(operations)) {\n          throw new MedicalError(\n            'Invalid stored operations format',\n            'INVALID_FORMAT',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.MEDIUM,\n          ).withContext({ type: typeof operations });\n        }\n\n        let loadedCount = 0;\n        let errorCount = 0;\n\n        operations.forEach((op, index) => {\n          try {\n            // Validate operation structure\n            if (!op || typeof op !== 'object' || !op.type || !op.entityType || !op.entityId) {\n              throw new Error(`Invalid operation structure at index ${index}`);\n            }\n\n            const operation = new MedicalSyncOperation(op.type, op.entityType, op.entityId, op.data, op.timestamp);\n            operation.attempts = Math.max(0, op.attempts || 0);\n            operation.status = op.status || 'pending';\n\n            // Skip operations that have exceeded max attempts\n            if (operation.attempts >= operation.maxAttempts) {\n              console.warn(`Skipping operation ${operation.id} - exceeded max attempts`);\n              return;\n            }\n\n            this.pendingOperations.set(operation.id, operation);\n            loadedCount++;\n          } catch (opError) {\n            console.warn(`Failed to load operation at index ${index}:`, opError.message);\n            errorCount++;\n          }\n        });\n\n        // (`📦 Loaded ${loadedCount} pending sync operations (${errorCount} errors)`);\n\n        return { loaded: loadedCount, errors: errorCount };\n      },\n      (error) => {\n        console.warn('Failed to load pending operations:', error.message);\n\n        // Clear corrupted data\n        try {\n          localStorage.removeItem('medical_sync_pending');\n        } catch (clearError) {\n          console.error('Failed to clear corrupted sync data:', clearError.message);\n        }\n\n        return { loaded: 0, errors: 1, cleared: true };\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        severity: ERROR_SEVERITY.LOW,\n        timeout: 5000,\n        context: {\n          operation: 'load_pending_operations',\n        },\n      },\n    );\n  }\n\n  /**\n   * Save pending operations to storage with comprehensive error handling\n   */\n  async savePendingOperations() {\n    return safeAsync(\n      async () => {\n        if (typeof localStorage === 'undefined') {\n          throw new MedicalError(\n            'Local storage not available',\n            'STORAGE_UNAVAILABLE',\n            ERROR_CATEGORIES.STORAGE,\n            ERROR_SEVERITY.MEDIUM,\n          );\n        }\n\n        const operations = Array.from(this.pendingOperations.values()).map((op) => {\n          try {\n            return {\n              id: op.id,\n              type: op.type,\n              entityType: op.entityType,\n              entityId: op.entityId,\n              data: op.data,\n              timestamp: op.timestamp,\n              attempts: op.attempts,\n              status: op.status,\n            };\n          } catch (serializeError) {\n            console.warn(`Failed to serialize operation ${op.id}:`, serializeError.message);\n            return null;\n          }\n        }).filter((op) => op !== null);\n\n        const serialized = JSON.stringify(operations);\n\n        // Check storage quota\n        if (serialized.length > 1024 * 1024) { // 1MB limit\n          console.warn('Sync operations data is very large, may hit storage limits');\n        }\n\n        localStorage.setItem('medical_sync_pending', serialized);\n\n        return { saved: operations.length };\n      },\n      (error) => {\n        console.error('Failed to save pending operations:', error.message);\n\n        // Try to clear space and retry once\n        if (error.name === 'QuotaExceededError') {\n          try {\n            // Remove oldest operations to make space\n            const operationsArray = Array.from(this.pendingOperations.entries());\n            const halfPoint = Math.floor(operationsArray.length / 2);\n            const toKeep = operationsArray.slice(-halfPoint);\n\n            this.pendingOperations.clear();\n            toKeep.forEach(([id, op]) => {\n              this.pendingOperations.set(id, op);\n            });\n\n            console.info(`Reduced operations from ${operationsArray.length} to ${toKeep.length} due to storage quota`);\n\n            // Retry save\n            const reducedOperations = toKeep.map(([, op]) => ({\n              id: op.id,\n              type: op.type,\n              entityType: op.entityType,\n              entityId: op.entityId,\n              data: op.data,\n              timestamp: op.timestamp,\n              attempts: op.attempts,\n              status: op.status,\n            }));\n\n            localStorage.setItem('medical_sync_pending', JSON.stringify(reducedOperations));\n            return { saved: reducedOperations.length, reduced: true };\n          } catch (retryError) {\n            console.error('Failed to save even after reducing operations:', retryError.message);\n            return { saved: 0, error: retryError.message };\n          }\n        }\n\n        return { saved: 0, error: error.message };\n      },\n      {\n        category: ERROR_CATEGORIES.STORAGE,\n        severity: ERROR_SEVERITY.LOW,\n        timeout: 5000,\n        context: {\n          operation: 'save_pending_operations',\n          operationCount: this.pendingOperations.size,\n        },\n      },\n    );\n  }\n\n  /**\n   * Clear all pending operations\n   */\n  clearPendingOperations() {\n    this.pendingOperations.clear();\n    this.conflictQueue.clear();\n    localStorage.removeItem('medical_sync_pending');\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_operations_cleared',\n    });\n  }\n\n  /**\n   * Configure sync settings\n   */\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n\n    // Restart periodic sync with new interval\n    if (this.syncInterval && newConfig.syncIntervalMs) {\n      this.stopPeriodicSync();\n      this.startPeriodicSync();\n    }\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_config_updated',\n      config: this.config,\n    });\n  }\n\n  /**\n   * Dispose and cleanup\n   */\n  dispose() {\n    this.stopPeriodicSync();\n    this.savePendingOperations();\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: 'sync_manager_disposed',\n    });\n  }\n}\n\n// Export singleton instance\nexport const medicalSyncManager = new MedicalSyncManager();\n","/**\n * Medical Service Worker for Offline-First Stroke Triage Assistant\n * iGFAP Stroke Triage Assistant - Phase 3 Advanced Features\n *\n * Provides intelligent offline capabilities for critical medical operations with bulletproof error handling\n */\n\n// Bulletproof error handling for service worker\nconst ERROR_CATEGORIES = {\n  CACHE: 'cache',\n  NETWORK: 'network',\n  MEDICAL: 'medical',\n  STORAGE: 'storage',\n};\n\nconst ERROR_SEVERITY = {\n  LOW: 'low',\n  MEDIUM: 'medium',\n  HIGH: 'high',\n  CRITICAL: 'critical',\n};\n\n/**\n * Safe async wrapper for service worker operations\n */\nasync function safeAsync(operation, fallback = null, context = {}) {\n  try {\n    return await operation();\n  } catch (error) {\n    console.error('Service Worker error:', error.message, context);\n\n    // Send error to main thread\n    try {\n      const clients = await self.clients.matchAll();\n      clients.forEach((client) => {\n        client.postMessage({\n          type: 'SW_ERROR',\n          error: {\n            message: error.message,\n            context,\n            timestamp: new Date().toISOString(),\n          },\n        });\n      });\n    } catch (msgError) {\n      console.error('Failed to send error message to clients:', msgError);\n    }\n\n    return typeof fallback === 'function' ? fallback(error) : fallback;\n  }\n}\n\nconst CACHE_VERSION = 'medical-app-v3.0.0';\nconst STATIC_CACHE_NAME = `${CACHE_VERSION}-static`;\nconst API_CACHE_NAME = `${CACHE_VERSION}-api`;\nconst RUNTIME_CACHE_NAME = `${CACHE_VERSION}-runtime`;\n\n// Critical resources that must be available offline\nconst CRITICAL_RESOURCES = [\n  '/0925/',\n  '/0925/index.html',\n  '/0925/src/main.js',\n  '/0925/src/app.js',\n  '/0925/src/config.js',\n  '/0925/src/state/store.js',\n  '/0925/src/logic/validate.js',\n  '/0925/src/logic/ich-volume-calculator.js',\n  '/0925/src/logic/lvo-local-model.js',\n  '/0925/src/ui/render.js',\n  '/0925/src/styles/app.css',\n  '/0925/manifest.json',\n  '/0925/icon-192.png',\n  '/0925/icon-512.png',\n];\n\n// API endpoints for intelligent caching\nconst API_ENDPOINTS = [\n  'https://europe-west3-igfap-452720.cloudfunctions.net/predict_coma_ich',\n  'https://europe-west3-igfap-452720.cloudfunctions.net/predict_limited_data_ich',\n  'https://europe-west3-igfap-452720.cloudfunctions.net/predict_full_stroke',\n];\n\n// Network strategies\nconst NETWORK_STRATEGIES = {\n  CACHE_FIRST: 'cache-first',\n  NETWORK_FIRST: 'network-first',\n  NETWORK_ONLY: 'network-only',\n  CACHE_ONLY: 'cache-only',\n  STALE_WHILE_REVALIDATE: 'stale-while-revalidate',\n};\n\n/**\n * Service Worker Installation with bulletproof error handling\n */\nself.addEventListener('install', (event) => {\n  // Medical Service Worker installing\n\n  event.waitUntil(\n    safeAsync(\n      async () => {\n        // Pre-cache critical resources with individual error handling\n        const staticCache = await caches.open(STATIC_CACHE_NAME);\n\n        // Cache resources individually to prevent single failure from blocking entire installation\n        const cacheResults = await Promise.allSettled(\n          CRITICAL_RESOURCES.map(async (resource) => {\n            try {\n              const response = await fetch(resource);\n              if (response.ok) {\n                return staticCache.put(resource, response);\n              }\n              throw new Error(`Failed to fetch ${resource}: ${response.status}`);\n            } catch (fetchError) {\n              console.warn(`Failed to cache critical resource ${resource}:`, fetchError.message);\n              return null;\n            }\n          }),\n        );\n\n        const successfulCaches = cacheResults.filter((result) => result.status === 'fulfilled').length;\n        const failedCaches = CRITICAL_RESOURCES.length - successfulCaches;\n\n        if (failedCaches > CRITICAL_RESOURCES.length / 2) {\n          throw new Error(`Too many critical resources failed to cache: ${failedCaches}/${CRITICAL_RESOURCES.length}`);\n        }\n\n        // Initialize API and runtime caches\n        await Promise.allSettled([\n          caches.open(API_CACHE_NAME),\n          caches.open(RUNTIME_CACHE_NAME),\n        ]);\n\n        // Medical Service Worker installed successfully\n\n        // Send installation success message\n        try {\n          const clients = await self.clients.matchAll();\n          clients.forEach((client) => {\n            client.postMessage({\n              type: 'SW_INSTALLED',\n              cacheVersion: CACHE_VERSION,\n              criticalResourcesCount: CRITICAL_RESOURCES.length,\n              successfulCaches,\n              failedCaches,\n              timestamp: new Date().toISOString(),\n            });\n          });\n        } catch (msgError) {\n          console.warn('Failed to send installation message:', msgError.message);\n        }\n\n        // Skip waiting to activate immediately\n        self.skipWaiting();\n\n        return { success: true, successfulCaches, failedCaches };\n      },\n      (error) => {\n        // Fallback for installation failure\n        console.error('Service Worker installation failed:', error.message);\n\n        try {\n          const clients = self.clients.matchAll();\n          clients.then((clientList) => {\n            clientList.forEach((client) => {\n              client.postMessage({\n                type: 'SW_INSTALL_ERROR',\n                error: error.message,\n                timestamp: new Date().toISOString(),\n              });\n            });\n          });\n        } catch (msgError) {\n          console.error('Failed to send installation error message:', msgError.message);\n        }\n\n        return { success: false, error: error.message };\n      },\n      {\n        operation: 'service_worker_installation',\n        criticalResourcesCount: CRITICAL_RESOURCES.length,\n      },\n    ),\n  );\n});\n\n/**\n * Service Worker Activation with bulletproof error handling\n */\nself.addEventListener('activate', (event) => {\n  // Medical Service Worker activating\n\n  event.waitUntil(\n    safeAsync(\n      async () => {\n        // Clean up old caches with individual error handling\n        const cacheNames = await caches.keys();\n        const oldCaches = cacheNames.filter((name) => name.startsWith('medical-app-v') && !name.includes(CACHE_VERSION));\n\n        const cleanupResults = await Promise.allSettled(\n          oldCaches.map(async (cacheName) => {\n            try {\n              const deleted = await caches.delete(cacheName);\n              return { cacheName, deleted };\n            } catch (error) {\n              console.warn(`Failed to delete cache ${cacheName}:`, error.message);\n              return { cacheName, deleted: false, error: error.message };\n            }\n          }),\n        );\n\n        const successfulCleanups = cleanupResults.filter((result) => result.status === 'fulfilled' && result.value.deleted).length;\n\n        // Cleaned up old caches\n\n        // Claim all clients with timeout\n        await Promise.race([\n          self.clients.claim(),\n          new Promise((_, reject) => setTimeout(() => reject(new Error('Client claim timeout')), 5000)),\n        ]);\n\n        // Medical Service Worker activated\n\n        // Notify clients of activation\n        const clients = await self.clients.matchAll();\n        const notificationPromises = clients.map((client) => {\n          try {\n            return client.postMessage({\n              type: 'SW_ACTIVATED',\n              cacheVersion: CACHE_VERSION,\n              cleanedCaches: successfulCleanups,\n              totalOldCaches: oldCaches.length,\n              timestamp: new Date().toISOString(),\n            });\n          } catch (error) {\n            console.warn('Failed to notify client of activation:', error.message);\n            return null;\n          }\n        });\n\n        await Promise.allSettled(notificationPromises);\n\n        return { success: true, cleanedCaches: successfulCleanups };\n      },\n      (error) => {\n        console.error('Service Worker activation failed:', error.message);\n\n        // Try to notify clients of activation failure\n        safeAsync(\n          async () => {\n            const clients = await self.clients.matchAll();\n            clients.forEach((client) => {\n              client.postMessage({\n                type: 'SW_ACTIVATION_ERROR',\n                error: error.message,\n                timestamp: new Date().toISOString(),\n              });\n            });\n          },\n          null,\n          { operation: 'activation_error_notification' },\n        );\n\n        return { success: false, error: error.message };\n      },\n      {\n        operation: 'service_worker_activation',\n      },\n    ),\n  );\n});\n\n/**\n * Fetch Event Handler with Intelligent Caching\n */\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests for caching\n  if (request.method !== 'GET') {\n    if (isAPIRequest(url)) {\n      // Handle API POST requests with intelligent offline behavior\n      event.respondWith(handleAPIRequest(request));\n    }\n    return;\n  }\n\n  // Route requests based on type\n  if (isAPIRequest(url)) {\n    event.respondWith(handleAPIRequest(request));\n  } else if (isStaticResource(url)) {\n    event.respondWith(handleStaticResource(request));\n  } else if (isAppShell(url)) {\n    event.respondWith(handleAppShell(request));\n  } else {\n    event.respondWith(handleRuntimeRequest(request));\n  }\n});\n\n/**\n * Handle API requests with medical data caching and bulletproof error handling\n */\nasync function handleAPIRequest(request) {\n  return safeAsync(\n    async () => {\n      const url = new URL(request.url);\n\n      // For POST requests (predictions), try network first with offline fallback\n      if (request.method === 'POST') {\n        return await handlePredictionRequest(request);\n      }\n\n      // For GET requests, use stale-while-revalidate\n      const cache = await caches.open(API_CACHE_NAME);\n      const cachedResponse = await cache.match(request);\n\n      // If we have a cached response, return it while updating in background\n      if (cachedResponse) {\n        // Update cache in background with error handling\n        safeAsync(\n          async () => {\n            const response = await fetch(request);\n            if (response.ok) {\n              await cache.put(request, response.clone());\n            }\n          },\n          null,\n          { operation: 'background_cache_update', url: request.url },\n        );\n\n        return cachedResponse;\n      }\n\n      // No cache, try network with timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000);\n\n      try {\n        const networkResponse = await fetch(request, {\n          signal: controller.signal,\n        });\n        clearTimeout(timeoutId);\n\n        if (networkResponse.ok) {\n          // Cache response with error handling\n          try {\n            await cache.put(request, networkResponse.clone());\n          } catch (cacheError) {\n            console.warn('Failed to cache API response:', cacheError.message);\n          }\n        }\n\n        return networkResponse;\n      } catch (fetchError) {\n        clearTimeout(timeoutId);\n        throw fetchError;\n      }\n    },\n    (error) => {\n      console.warn('API request failed, returning offline fallback:', error.message);\n      return createOfflineFallbackResponse(request);\n    },\n    {\n      operation: 'api_request_handling',\n      url: request.url,\n      method: request.method,\n    },\n  );\n}\n\n/**\n * Handle prediction API requests with intelligent offline support and bulletproof error handling\n */\nasync function handlePredictionRequest(request) {\n  return safeAsync(\n    async () => {\n      // Clone request for potential retry\n      const requestClone = request.clone();\n\n      // Try network first (critical for real-time predictions)\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout\n\n      try {\n        const networkResponse = await fetch(request, {\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (networkResponse.ok) {\n          // Cache successful prediction for offline reference with error handling\n          safeAsync(\n            async () => {\n              const cache = await caches.open(API_CACHE_NAME);\n              const cacheKey = await createPredictionCacheKey(requestClone);\n\n              // Store with timestamp for freshness checking\n              const responseWithMetadata = await addCacheMetadata(networkResponse.clone());\n              await cache.put(cacheKey, responseWithMetadata);\n            },\n            null,\n            { operation: 'prediction_cache_storage', url: request.url },\n          );\n\n          return networkResponse;\n        }\n\n        throw new Error(`API returned ${networkResponse.status}: ${networkResponse.statusText}`);\n      } catch (fetchError) {\n        clearTimeout(timeoutId);\n        throw fetchError;\n      }\n    },\n    async (error) => {\n      console.warn('Network prediction failed, trying offline alternatives:', error.message);\n\n      // Try local LVO model if available\n      const localPrediction = await safeAsync(\n        () => tryLocalPrediction(request),\n        null,\n        { operation: 'local_prediction_attempt' },\n      );\n\n      if (localPrediction) {\n        return localPrediction;\n      }\n\n      // Return cached similar prediction if available\n      const cachedPrediction = await safeAsync(\n        () => findSimilarCachedPrediction(request),\n        null,\n        { operation: 'cached_prediction_lookup' },\n      );\n\n      if (cachedPrediction) {\n        return cachedPrediction;\n      }\n\n      // Return offline guidance response\n      return createOfflinePredictionGuidance();\n    },\n    {\n      operation: 'prediction_request_handling',\n      url: request.url,\n    },\n  );\n}\n\n/**\n * Try local LVO prediction model when offline with comprehensive error handling\n */\nasync function tryLocalPrediction(request) {\n  return safeAsync(\n    async () => {\n      // Safe request body parsing\n      let data;\n      try {\n        const body = await request.text();\n        data = JSON.parse(body);\n      } catch (parseError) {\n        throw new Error(`Failed to parse request body: ${parseError.message}`);\n      }\n\n      // Validate required data\n      if (!data || typeof data !== 'object') {\n        throw new Error('Invalid request data format');\n      }\n\n      // Check if we can use local LVO model\n      if (request.url.includes('predict_full_stroke')) {\n        // Validate required fields\n        if (!data.gfap_value || !data.fast_ed_score) {\n          throw new Error('Missing required fields for local LVO prediction');\n        }\n\n        // Validate field ranges\n        if (data.gfap_value < 0 || data.gfap_value > 10000) {\n          throw new Error('GFAP value out of valid range');\n        }\n\n        if (data.fast_ed_score < 0 || data.fast_ed_score > 10) {\n          throw new Error('FAST-ED score out of valid range');\n        }\n\n        // Calculate local prediction with error handling\n        const localResult = calculateLocalLVO(data.gfap_value, data.fast_ed_score);\n\n        if (!localResult || typeof localResult !== 'object') {\n          throw new Error('Local LVO calculation failed');\n        }\n\n        return new Response(JSON.stringify({\n          ...localResult,\n          source: 'local_model',\n          offline: true,\n          timestamp: new Date().toISOString(),\n          warning: 'This is an offline prediction using a simplified model. Seek professional medical advice.',\n        }), {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        });\n      }\n\n      return null;\n    },\n    (error) => {\n      console.warn('Local prediction failed:', error.message);\n      return null;\n    },\n    {\n      operation: 'local_prediction',\n      url: request.url,\n    },\n  );\n}\n\n/**\n * Simplified local LVO calculation with safety checks\n */\nfunction calculateLocalLVO(gfap, fastEd) {\n  try {\n    // Input validation\n    if (typeof gfap !== 'number' || typeof fastEd !== 'number') {\n      throw new Error('GFAP and FAST-ED values must be numbers');\n    }\n\n    if (!isFinite(gfap) || !isFinite(fastEd)) {\n      throw new Error('GFAP and FAST-ED values must be finite numbers');\n    }\n\n    if (gfap < 0 || fastEd < 0) {\n      throw new Error('GFAP and FAST-ED values cannot be negative');\n    }\n\n    // Simplified logic - in practice, this would use the full model\n    const gfapScore = gfap > 500 ? 0.4 : gfap > 200 ? 0.2 : 0.1;\n    const fastEdScore = fastEd >= 4 ? 0.5 : fastEd >= 2 ? 0.3 : 0.1;\n\n    const lvoProb = Math.min(0.95, gfapScore + fastEdScore);\n    const ichProb = Math.max(0.05, Math.min(0.5, gfap / 2000)); // Very conservative ICH estimate\n\n    // Validate calculated probabilities\n    if (!isFinite(lvoProb) || !isFinite(ichProb)\n        || lvoProb < 0 || lvoProb > 1 || ichProb < 0 || ichProb > 1) {\n      throw new Error('Calculated probabilities are invalid');\n    }\n\n    return {\n      lvo: {\n        probability: Math.round(lvoProb * 100) / 100, // Round to 2 decimal places\n        confidence: 0.6, // Lower confidence for offline model\n        module: 'Local Offline Model',\n        warning: 'Simplified offline calculation - not for clinical decisions',\n      },\n      ich: {\n        probability: Math.round(ichProb * 100) / 100,\n        confidence: 0.4, // Very low confidence for ICH estimation\n        module: 'Local Offline Model',\n        warning: 'Conservative estimate - seek immediate medical evaluation',\n      },\n      metadata: {\n        calculatedAt: new Date().toISOString(),\n        inputs: { gfap, fastEd },\n        disclaimer: 'This is a simplified offline model for emergency use only. Clinical judgment and professional medical evaluation are essential.',\n      },\n    };\n  } catch (error) {\n    console.error('Local LVO calculation failed:', error.message);\n\n    // Return safe fallback values\n    return {\n      lvo: {\n        probability: 0.1,\n        confidence: 0.1,\n        module: 'Emergency Fallback',\n        error: 'Calculation failed - using minimum risk estimate',\n      },\n      ich: {\n        probability: 0.1,\n        confidence: 0.1,\n        module: 'Emergency Fallback',\n        error: 'Calculation failed - using minimum risk estimate',\n      },\n      metadata: {\n        calculatedAt: new Date().toISOString(),\n        error: error.message,\n        disclaimer: 'Calculation failed. Immediate medical evaluation required.',\n      },\n    };\n  }\n}\n\n/**\n * Handle static resources with cache-first strategy\n */\nasync function handleStaticResource(request) {\n  const cache = await caches.open(STATIC_CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    // For critical resources, return a service unavailable response\n    return new Response('Service temporarily unavailable', {\n      status: 503,\n      statusText: 'Service Unavailable',\n    });\n  }\n}\n\n/**\n * Handle app shell with network-first, cache fallback\n */\nasync function handleAppShell(request) {\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      const cache = await caches.open(RUNTIME_CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    const cache = await caches.open(STATIC_CACHE_NAME);\n    const cachedResponse = await cache.match('/0925/index.html');\n\n    return cachedResponse || new Response('App temporarily unavailable', {\n      status: 503,\n      statusText: 'Service Unavailable',\n    });\n  }\n}\n\n/**\n * Handle runtime requests\n */\nasync function handleRuntimeRequest(request) {\n  const cache = await caches.open(RUNTIME_CACHE_NAME);\n\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await cache.match(request);\n    return cachedResponse || fetch(request);\n  }\n}\n\n/**\n * Utility functions\n */\nfunction isAPIRequest(url) {\n  return API_ENDPOINTS.some((endpoint) => url.href.startsWith(endpoint));\n}\n\nfunction isStaticResource(url) {\n  return url.pathname.includes('/src/')\n         || url.pathname.includes('/styles/')\n         || url.pathname.endsWith('.css')\n         || url.pathname.endsWith('.js')\n         || url.pathname.endsWith('.png')\n         || url.pathname.endsWith('.ico');\n}\n\nfunction isAppShell(url) {\n  return url.pathname === '/0925/'\n         || url.pathname === '/0925/index.html'\n         || url.pathname.endsWith('/');\n}\n\nasync function createPredictionCacheKey(request) {\n  const body = await request.text();\n  const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(body));\n  const hashArray = Array.from(new Uint8Array(hash));\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n\n  return `${request.url}#${hashHex}`;\n}\n\nasync function addCacheMetadata(response) {\n  const data = await response.json();\n  const responseWithMetadata = {\n    ...data,\n    _cached: true,\n    _cachedAt: Date.now(),\n    _cacheVersion: CACHE_VERSION,\n  };\n\n  return new Response(JSON.stringify(responseWithMetadata), {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n  });\n}\n\nasync function findSimilarCachedPrediction(request) {\n  // Implementation would find similar cached predictions\n  // This is a placeholder for more sophisticated matching\n  return null;\n}\n\nfunction createOfflineFallbackResponse(request) {\n  return new Response(JSON.stringify({\n    error: 'Network unavailable',\n    offline: true,\n    guidance: 'Please check your network connection. For emergency situations, contact your local emergency services immediately.',\n    timestamp: new Date().toISOString(),\n  }), {\n    status: 503,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n\nfunction createOfflinePredictionGuidance() {\n  return new Response(JSON.stringify({\n    offline: true,\n    guidance: {\n      message: 'Prediction services are currently unavailable. Please use clinical judgment and standard stroke protocols.',\n      recommendations: [\n        'Assess patient using standard NIHSS scoring',\n        'Consider time since symptom onset',\n        'Evaluate for contraindications to thrombolysis',\n        'Contact stroke team or neurologist if available',\n        'If in doubt, treat as potential stroke emergency',\n      ],\n    },\n    emergency: 'For immediate emergency response, contact your local emergency services',\n    timestamp: new Date().toISOString(),\n  }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n\n/**\n * Background Sync for Medical Data\n */\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'medical-data-sync') {\n    event.waitUntil(syncMedicalData());\n  }\n});\n\nasync function syncMedicalData() {\n  // Syncing medical data\n\n  try {\n    // Sync any pending medical data when connection is restored\n    // This would include patient data, predictions, etc.\n\n    // Notify clients of successful sync\n    const clients = await self.clients.matchAll();\n    clients.forEach((client) => {\n      client.postMessage({\n        type: 'MEDICAL_DATA_SYNCED',\n        timestamp: new Date().toISOString(),\n      });\n    });\n  } catch (error) {\n    // Medical data sync failed\n  }\n}\n\n/**\n * Push Notifications for Medical Alerts\n */\nself.addEventListener('push', (event) => {\n  if (event.data) {\n    const data = event.data.json();\n\n    if (data.type === 'medical-alert') {\n      event.waitUntil(showMedicalNotification(data));\n    }\n  }\n});\n\nasync function showMedicalNotification(data) {\n  const options = {\n    body: data.message,\n    icon: '/0925/icon-192.png',\n    badge: '/0925/icon-192.png',\n    vibrate: [200, 100, 200],\n    requireInteraction: true,\n    actions: [\n      {\n        action: 'view',\n        title: 'View Details',\n      },\n      {\n        action: 'dismiss',\n        title: 'Dismiss',\n      },\n    ],\n  };\n\n  await self.registration.showNotification(data.title, options);\n}\n\n/**\n * Notification Click Handler\n */\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close();\n\n  if (event.action === 'view') {\n    event.waitUntil(\n      self.clients.openWindow('/0925/'),\n    );\n  }\n});\n\n/**\n * Message Handler for Communication with Main Thread\n */\nself.addEventListener('message', (event) => {\n  const { type, data } = event.data;\n\n  switch (type) {\n    case 'SKIP_WAITING':\n      self.skipWaiting();\n      break;\n\n    case 'GET_CACHE_STATUS':\n      event.ports[0].postMessage(getCacheStatus());\n      break;\n\n    case 'CLEAR_CACHE':\n      event.waitUntil(clearAllCaches());\n      break;\n\n    case 'PREFETCH_RESOURCES':\n      event.waitUntil(prefetchResources(data.resources));\n      break;\n  }\n});\n\nasync function getCacheStatus() {\n  const caches = await self.caches.keys();\n  const status = {};\n\n  for (const cacheName of caches) {\n    const cache = await self.caches.open(cacheName);\n    const keys = await cache.keys();\n    status[cacheName] = keys.length;\n  }\n\n  return {\n    version: CACHE_VERSION,\n    caches: status,\n    timestamp: new Date().toISOString(),\n  };\n}\n\nasync function clearAllCaches() {\n  const cacheNames = await caches.keys();\n  await Promise.all(\n    cacheNames.map((cacheName) => caches.delete(cacheName)),\n  );\n\n  // All caches cleared\n}\n\nasync function prefetchResources(resources) {\n  const cache = await caches.open(RUNTIME_CACHE_NAME);\n\n  for (const resource of resources) {\n    try {\n      const response = await fetch(resource);\n      if (response.ok) {\n        await cache.put(resource, response);\n      }\n    } catch (error) {\n      // Failed to prefetch resource\n    }\n  }\n}\n\n// Medical Service Worker loaded\n"],"names":["ALLOWED_TAGS","ALLOWED_ATTRIBUTES","ALLOWED_STYLES","sanitizeHTML","html","options","containsXSSPatterns","doc","sanitizeNode","pattern","node","nodesToRemove","child","tagName","sanitizeAttributes","nodeToRemove","element","allowedAttrs","attrsToRemove","i","attr","attrName","isDataAttr","sanitizeStyleAttribute","escapeAttributeValue","styleValue","styles","sanitizedStyles","style","property","value","s","safeSetInnerHTML","sanitizedHTML","error","EnvironmentConfig","define_process_env_default","clientConfig","key","defaultValue","type","service","array","byte","issues","warnings","researchPassword","sessionSecret","safeKeys","safeConfig","ERROR_SEVERITY","ERROR_CATEGORIES","MedicalError","message","code","category","severity","context","GlobalErrorHandler","event","errorEntry","alert","globalErrorHandler","safeAsync","asyncFn","fallback","timeout","retries","attempt","timeoutPromise","_","reject","resolve","safeAuthOperation","authFn","LOG_LEVELS","LOG_CATEGORIES","MedicalLogger","stored","timestamp","random","_a","loggingError","_b","level","safeContext","entry","userId","sanitized","sensitiveFields","removeSensitiveData","obj","cleaned","lowerKey","field","sessionData","navigation","performance","levelInfo","serialized","keys","operation","result","action","success","url","method","status","metric","urlObj","param","filters","allLogs","log","filtered","a","b","minLevel","sinceDate","format","logs","headers","rows","row","medicalLogger","debug","info","warn","critical","medicalCalculation","authentication","userInteraction","networkRequest","auditTrail","MedicalDataEncryption","keyMaterial","keyData","randomBytes","keyBytes","data","jsonString","dataBytes","iv","encryptedBuffer","encryptedArray","encryptedBase64","ivBase64","encryptedData","encryptedDataString","parseError","encryptedBytes","char","decryptedBuffer","decryptedString","decryptedData","useSessionStorage","storage","storageKey","legacyData","dataString","parsed","parsedData","medicalEncryption","secureRetrieve","secureRemove","MedicalServiceWorkerManager","metricId","medicalPerformanceMonitor","PerformanceMetricType","registrationPromise","medicalEventObserver","MEDICAL_EVENTS","newWorker","isOnline","registration","notification","htmlError","fallbackError","updatePromise","retryDelay","channel","postError","resources","enabled","OfflineInstallPrompt","swManager","banner","bannerContent","bannerText","title","description","bannerActions","installButton","dismissButton","medicalSWManager","offlineInstallPrompt","CacheStorageType","CachePriority","MedicalCacheTTL","CacheEntry","ttl","priority","metadata","priorityWeight","accessWeight","ageWeight","MedicalCache","storageType","cacheData","entryData","size","oldEntry","entriesCleared","lowestScore","keyToEvict","score","startTime","cleanedCount","duration","e","hitRate","MedicalCacheFactory","cache","__publicField","predictionCache","SyncOperationType","SyncStatus","ConflictResolution","MedicalSyncOperation","entityType","entityId","MedicalSyncManager","oldestKey","completedCount","errorCount","conflictCount","operations","batchSize","maxSyncTime","batch","op","results","conflict","conflictResult","conflictId","resolvedData","resolutionOperation","clientData","serverData","merged","loadedCount","index","opError","clearError","serializeError","operationsArray","halfPoint","toKeep","id","reducedOperations","retryError","newConfig","medicalSyncManager","client","msgError","CACHE_VERSION","STATIC_CACHE_NAME","API_CACHE_NAME","RUNTIME_CACHE_NAME","CRITICAL_RESOURCES","API_ENDPOINTS","staticCache","successfulCaches","resource","response","fetchError","failedCaches","clientList","oldCaches","name","successfulCleanups","cacheName","deleted","notificationPromises","request","isAPIRequest","handleAPIRequest","isStaticResource","handleStaticResource","isAppShell","handleAppShell","handleRuntimeRequest","handlePredictionRequest","cachedResponse","controller","timeoutId","networkResponse","cacheError","createOfflineFallbackResponse","requestClone","cacheKey","createPredictionCacheKey","responseWithMetadata","addCacheMetadata","localPrediction","tryLocalPrediction","cachedPrediction","findSimilarCachedPrediction","createOfflinePredictionGuidance","body","localResult","calculateLocalLVO","gfap","fastEd","gfapScore","fastEdScore","lvoProb","ichProb","endpoint","hash","hashHex","syncMedicalData","showMedicalNotification","getCacheStatus","clearAllCaches","prefetchResources","caches","cacheNames"],"mappings":"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"}